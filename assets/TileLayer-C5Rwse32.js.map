{"version":3,"file":"TileLayer-C5Rwse32.js","sources":["../../node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {import(\"../../source/Tile.js\").default} source The tile source.\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(source, sourceKey, z, x, y) {\n  return `${getUid(source)},${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"names":["getCacheKey","source","sourceKey","z","x","y","getUid","getKeyZXY","addTileToLookup","tilesByZ","tile","set","existing","removeTileFromLookup","getRenderExtent","frameState","extent","layerState","getIntersection","fromUserExtent","gridExtent","CanvasTileLayerRenderer","CanvasLayerRenderer","tileLayer","options","createEmpty","TileRange","createTileCoord","cacheSize","LRUCache","tileCache","tileSource","cacheKey","pixel","layer","coordinate","applyTransform","layerExtent","containsCoordinate","viewState","tileGrid","tilePixelRatio","tileCoord","TileState","tileOrigin","tileSize","toSize","tileResolution","image","ImageTile","ReprojTile","DataTile","asImageLike","col","row","gutter","sourceRevision","initialZ","preload","tileSourceKey","wantedTiles","map","minZ","rotation","viewport","getRotatedViewport","tileRange","tileQueueKey","staleKeys","i","altZ","covered","loaded","target","projection","viewResolution","viewCenter","pixelRatio","frameExtent","width","height","dx","dy","canvasExtent","targetZ","nextExtent","renderExtent","uid","time","tileState","minZoom","parentZ","canvasScale","context","composeTransform","zs","ascending","currentClip","clips","clipZs","currentZ","currentTilePixelSize","currentScale","originTileCoord","getTopLeft","originTileExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","intersects","equals","postRenderFunction","tilesCount","tileCount","alpha","alphaChanged","usedTiles"],"mappings":"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","x_google_ignoreList":[0]}