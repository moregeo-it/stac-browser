{"version":3,"file":"VectorStyleRenderer-W9NXHFGV.js","sources":["../../node_modules/ol/render/webgl/MixedGeometryBatch.js","../../node_modules/ol/render/webgl/renderinstructions.js","../../node_modules/ol/render/webgl/VectorStyleRenderer.js"],"sourcesContent":["/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport {inflateEnds} from '../../geom/flat/orient.js';\nimport RenderFeature from '../../render/Feature.js';\nimport {getUid} from '../../util.js';\n\n/**\n * @typedef {import(\"../../Feature.js\").default} Feature\n */\n/**\n * @typedef {import(\"../../geom/Geometry.js\").Type} GeometryType\n */\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {Feature|RenderFeature} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n * @property {number} [ref] The reference in the global batch (used for hit detection)\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    /**\n     * @private\n     */\n    this.globalCounter_ = 0;\n\n    /**\n     * Refs are used as keys for hit detection.\n     * @type {Map<number, Feature|RenderFeature>}\n     * @private\n     */\n    this.refToFeature_ = new Map();\n\n    /**\n     * Features are split in \"entries\", which are individual geometries. We use the following map to share a single ref for all those entries.\n     * @type {Map<string, number>}\n     * @private\n     */\n    this.uidToRef_ = new Map();\n\n    /**\n     * The precision in WebGL shaders is limited.\n     * To keep the refs as small as possible we maintain an array of freed up references.\n     * @type {Array<number>}\n     * @private\n     */\n    this.freeGlobalRef_ = [];\n\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0,\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0,\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n    };\n  }\n\n  /**\n   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeatures(features, projectionTransform) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i], projectionTransform);\n    }\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeature(feature, projectionTransform) {\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.pointBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.lineStringBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.polygonBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {import(\"../../geom.js\").Geometry|RenderFeature} geometry Geometry\n   * @param {Feature|RenderFeature} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    switch (type) {\n      case 'GeometryCollection': {\n        const geometries =\n          /** @type {import(\"../../geom.js\").GeometryCollection} */ (\n            geometry\n          ).getGeometriesArray();\n        for (const geometry of geometries) {\n          this.addGeometry_(geometry, feature);\n        }\n        break;\n      }\n      case 'MultiPolygon': {\n        const multiPolygonGeom =\n          /** @type {import(\"../../geom.js\").MultiPolygon} */ (geometry);\n        this.addCoordinates_(\n          type,\n          multiPolygonGeom.getFlatCoordinates(),\n          multiPolygonGeom.getEndss(),\n          feature,\n          getUid(feature),\n          multiPolygonGeom.getStride(),\n        );\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineGeom =\n          /** @type {import(\"../../geom.js\").MultiLineString|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiLineGeom.getFlatCoordinates(),\n          multiLineGeom.getEnds(),\n          feature,\n          getUid(feature),\n          multiLineGeom.getStride(),\n        );\n        break;\n      }\n      case 'MultiPoint': {\n        const multiPointGeom =\n          /** @type {import(\"../../geom.js\").MultiPoint|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiPointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          multiPointGeom.getStride(),\n        );\n        break;\n      }\n      case 'Polygon': {\n        const polygonGeom =\n          /** @type {import(\"../../geom.js\").Polygon|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          polygonGeom.getFlatCoordinates(),\n          polygonGeom.getEnds(),\n          feature,\n          getUid(feature),\n          polygonGeom.getStride(),\n        );\n        break;\n      }\n      case 'Point': {\n        const pointGeom = /** @type {import(\"../../geom.js\").Point} */ (\n          geometry\n        );\n        this.addCoordinates_(\n          type,\n          pointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          pointGeom.getStride(),\n        );\n        break;\n      }\n      case 'LineString':\n      case 'LinearRing': {\n        const lineGeom = /** @type {import(\"../../geom.js\").LineString} */ (\n          geometry\n        );\n\n        const stride = lineGeom.getStride();\n\n        this.addCoordinates_(\n          type,\n          lineGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          stride,\n          lineGeom.getLayout?.(),\n        );\n        break;\n      }\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {GeometryType} type Geometry type\n   * @param {Array<number>} flatCoords Flat coordinates\n   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {string} featureUid Feature uid\n   * @param {number} stride Stride\n   * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout\n   * @private\n   */\n  addCoordinates_(type, flatCoords, ends, feature, featureUid, stride, layout) {\n    /** @type {number} */\n    let verticesCount;\n    switch (type) {\n      case 'MultiPolygon': {\n        const multiPolygonEndss = /** @type {Array<Array<number>>} */ (ends);\n        for (let i = 0, ii = multiPolygonEndss.length; i < ii; i++) {\n          let polygonEnds = multiPolygonEndss[i];\n          const prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;\n          const startIndex = prevPolygonEnds\n            ? prevPolygonEnds[prevPolygonEnds.length - 1]\n            : 0;\n          const endIndex = polygonEnds[polygonEnds.length - 1];\n          polygonEnds =\n            startIndex > 0\n              ? polygonEnds.map((end) => end - startIndex)\n              : polygonEnds;\n          this.addCoordinates_(\n            'Polygon',\n            flatCoords.slice(startIndex, endIndex),\n            polygonEnds,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineEnds = /** @type {Array<number>} */ (ends);\n        for (let i = 0, ii = multiLineEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? multiLineEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LineString',\n            flatCoords.slice(startIndex, multiLineEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'MultiPoint':\n        for (let i = 0, ii = flatCoords.length; i < ii; i += stride) {\n          this.addCoordinates_(\n            'Point',\n            flatCoords.slice(i, i + 2),\n            null,\n            feature,\n            featureUid,\n            null,\n            null,\n          );\n        }\n        break;\n      case 'Polygon': {\n        const polygonEnds = /** @type {Array<number>} */ (ends);\n        if (feature instanceof RenderFeature) {\n          const multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);\n          if (multiPolygonEnds.length > 1) {\n            this.addCoordinates_(\n              'MultiPolygon',\n              flatCoords,\n              multiPolygonEnds,\n              feature,\n              featureUid,\n              stride,\n              layout,\n            );\n            return;\n          }\n        }\n        if (!this.polygonBatch.entries[featureUid]) {\n          this.polygonBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n              ringsCount: 0,\n              ringsVerticesCounts: [],\n            },\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        const ringsCount = ends.length;\n        const ringsVerticesCount = ends.map((end, ind, arr) =>\n          ind > 0 ? (end - arr[ind - 1]) / stride : end / stride,\n        );\n        this.polygonBatch.verticesCount += verticesCount;\n        this.polygonBatch.ringsCount += ringsCount;\n        this.polygonBatch.geometriesCount++;\n        this.polygonBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXY(flatCoords, stride),\n        );\n        this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(\n          ringsVerticesCount,\n        );\n        this.polygonBatch.entries[featureUid].verticesCount += verticesCount;\n        this.polygonBatch.entries[featureUid].ringsCount += ringsCount;\n        for (let i = 0, ii = polygonEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? polygonEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LinearRing',\n            flatCoords.slice(startIndex, polygonEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride,\n            layout,\n          );\n        }\n        break;\n      }\n      case 'Point':\n        if (!this.pointBatch.entries[featureUid]) {\n          this.pointBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n            },\n          );\n        }\n        this.pointBatch.geometriesCount++;\n        this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        if (!this.lineStringBatch.entries[featureUid]) {\n          this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n            },\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        this.lineStringBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXYM(flatCoords, stride, layout),\n        );\n        this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {string} featureUid Feature uid\n   * @param {GeometryBatchItem} entry The entry to add\n   * @return {GeometryBatchItem} the added entry\n   * @private\n   */\n  addRefToEntry_(featureUid, entry) {\n    const currentRef = this.uidToRef_.get(featureUid);\n\n    // the ref starts at 1 to distinguish from white color (no feature)\n    const ref =\n      currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;\n    entry.ref = ref;\n    if (!currentRef) {\n      this.refToFeature_.set(ref, entry.feature);\n      this.uidToRef_.set(featureUid, ref);\n    }\n    return entry;\n  }\n\n  /**\n   * Return a ref to the pool of available refs.\n   * @param {number} ref the ref to return\n   * @param {string} featureUid the feature uid\n   * @private\n   */\n  removeRef_(ref, featureUid) {\n    if (!ref) {\n      throw new Error('This feature has no ref: ' + featureUid);\n    }\n    this.refToFeature_.delete(ref);\n    this.uidToRef_.delete(featureUid);\n    this.freeGlobalRef_.push(ref);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  changeFeature(feature, projectionTransform) {\n    // the feature is not present in the batch; do not add it to avoid unexpected behaviors\n    if (!this.uidToRef_.get(getUid(feature))) {\n      return;\n    }\n    this.removeFeature(feature);\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  removeFeature(feature) {\n    let entry = this.clearFeatureEntryInPointBatch_(feature);\n    entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;\n    if (entry) {\n      this.removeRef_(entry.ref, getUid(entry.feature));\n    }\n  }\n\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n    this.globalCounter_ = 0;\n    this.freeGlobalRef_ = [];\n    this.refToFeature_.clear();\n    this.uidToRef_.clear();\n  }\n\n  /**\n   * Resolve the feature associated to a ref.\n   * @param {number} ref Hit detected ref\n   * @return {Feature|RenderFeature} feature\n   */\n  getFeatureFromRef(ref) {\n    return this.refToFeature_.get(ref);\n  }\n\n  isEmpty() {\n    return this.globalCounter_ === 0;\n  }\n\n  /**\n   * Will return a new instance of this class that only contains the features\n   * for which the provided callback returned true\n   * @param {function((Feature|RenderFeature)): boolean} featureFilter Feature filter callback\n   * @return {MixedGeometryBatch} Filtered geometry batch\n   */\n  filter(featureFilter) {\n    const filtered = new MixedGeometryBatch();\n    filtered.globalCounter_ = this.globalCounter_;\n    filtered.uidToRef_ = this.uidToRef_;\n    filtered.refToFeature_ = this.refToFeature_;\n    let empty = true;\n    for (const feature of this.refToFeature_.values()) {\n      if (featureFilter(feature)) {\n        filtered.addFeature(feature);\n        empty = false;\n      }\n    }\n    // no feature was added at all; simply return an empty batch for consistency downstream\n    if (empty) {\n      return new MixedGeometryBatch();\n    }\n    return filtered;\n  }\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXY(flatCoords, stride) {\n  if (stride === 2) {\n    return flatCoords;\n  }\n  return flatCoords.filter((v, i) => i % stride < 2);\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @param {string} layout Layout\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXYM(flatCoords, stride, layout) {\n  if (stride === 3 && layout === 'XYM') {\n    return flatCoords;\n  }\n  // this is XYZM layout\n  if (stride === 4) {\n    return flatCoords.filter((v, i) => i % stride !== 2);\n  }\n  // this is XYZ layout\n  if (stride === 3) {\n    return flatCoords.map((v, i) => (i % stride !== 2 ? v : 0));\n  }\n  // this is XY layout\n  return new Array(flatCoords.length * 1.5)\n    .fill(0)\n    .map((v, i) => (i % 3 === 2 ? 0 : flatCoords[Math.round(i / 1.5)]));\n}\n\nexport default MixedGeometryBatch;\n","/**\n * @module ol/render/webgl/renderinstructions\n */\nimport {UNDEFINED_PROP_VALUE} from '../../expr/gpu.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {apply as applyTransform} from '../../transform.js';\n\n/**\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"./MixedGeometryBatch.js\").GeometryBatchItem} batchEntry Batch item\n * @param {number} currentIndex Current index\n * @return {number} The amount of values pushed\n */\nfunction pushCustomAttributesInRenderInstructions(\n  renderInstructions,\n  customAttributes,\n  batchEntry,\n  currentIndex,\n) {\n  let shift = 0;\n  for (const key in customAttributes) {\n    const attr = customAttributes[key];\n    const value = attr.callback.call(batchEntry, batchEntry.feature);\n    let first = value?.[0] ?? value;\n    if (first === UNDEFINED_PROP_VALUE) {\n      console.warn('The \"has\" operator might return false positives.'); // eslint-disable-line no-console\n    }\n    if (first === undefined) {\n      first = UNDEFINED_PROP_VALUE;\n    } else if (first === null) {\n      first = 0;\n    }\n    renderInstructions[currentIndex + shift++] = first;\n    if (!attr.size || attr.size === 1) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[1];\n    if (attr.size < 3) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[2];\n    if (attr.size < 4) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[3];\n  }\n  return shift;\n}\n\n/**\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @return {number} Cumulated size of all attributes\n */\nexport function getCustomAttributesSize(customAttributes) {\n  return Object.keys(customAttributes).reduce(\n    (prev, curr) => prev + (customAttributes[curr].size || 1),\n    0,\n  );\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePointRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for points:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per vertex per custom attributes\n  const totalInstructionsCount =\n    (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const tmpCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      tmpCoords[0] = batchEntry.flatCoordss[i][0];\n      tmpCoords[1] = batchEntry.flatCoordss[i][1];\n      applyTransform(transform, tmpCoords);\n\n      renderInstructions[renderIndex++] = tmpCoords[0];\n      renderInstructions[renderIndex++] = tmpCoords[1];\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Line String geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generateLineStringRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for lines:\n  // 3 instructions per vertex for position (x, y and m)\n  // + 1 instruction per line per custom attributes\n  // + 1 instruction per line (for vertices count)\n  const totalInstructionsCount =\n    3 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        3,\n        transform,\n        flatCoords,\n        3,\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n\n      // vertices count\n      renderInstructions[renderIndex++] = flatCoords.length / 3;\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 3) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n        renderInstructions[renderIndex++] = flatCoords[j + 2];\n      }\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for polygons are structured like so:\n * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePolygonRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform,\n) {\n  // here we anticipate the amount of render instructions for polygons:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per polygon per custom attributes\n  // + 1 instruction per polygon (for vertices count in polygon)\n  // + 1 instruction per ring (for vertices count in ring)\n  const totalInstructionsCount =\n    2 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount +\n    batch.ringsCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        2,\n        transform,\n        flatCoords,\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex,\n      );\n\n      // ring count\n      renderInstructions[renderIndex++] =\n        batchEntry.ringsVerticesCounts[i].length;\n\n      // vertices count in each ring\n      for (\n        let j = 0, jj = batchEntry.ringsVerticesCounts[i].length;\n        j < jj;\n        j++\n      ) {\n        renderInstructions[renderIndex++] =\n          batchEntry.ringsVerticesCounts[i][j];\n      }\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}\n","/**\n * @module ol/render/webgl/VectorStyleRenderer\n */\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {\n  BooleanType,\n  computeGeometryType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n} from '../../transform.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {WebGLWorkerMessageType} from './constants.js';\nimport {colorEncodeId} from './encodeUtil.js';\nimport {\n  generateLineStringRenderInstructions,\n  generatePointRenderInstructions,\n  generatePolygonRenderInstructions,\n  getCustomAttributesSize,\n} from './renderinstructions.js';\nimport {parseLiteralStyle} from './style.js';\n\nconst tmpColor = [];\n/** @type {Worker|undefined} */\nlet WEBGL_WORKER;\nfunction getWebGLWorker() {\n  if (!WEBGL_WORKER) {\n    WEBGL_WORKER = createWebGLWorker();\n  }\n  return WEBGL_WORKER;\n}\nlet workerMessageCounter = 0;\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  MEASURE_START: 'a_measureStart',\n  MEASURE_END: 'a_measureEnd',\n  PARAMETERS: 'a_parameters',\n  JOIN_ANGLES: 'a_joinAngles',\n  DISTANCE: 'a_distance',\n};\n\n/**\n * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value\n * of the callback should be an array; if unspecified, assumed to be a single float value\n * @property {function(this:import(\"./MixedGeometryBatch.js\").GeometryBatchItem, import(\"../../Feature\").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\n/**\n * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions\n * @typedef {Object<string, import(\"../../webgl/Helper\").UniformValue>} UniformDefinitions\n */\n\n/**\n * @typedef {Object} WebGLBuffers\n * @property {Array<WebGLArrayBuffer>} polygonBuffers Array containing indices and vertices buffers for polygons\n * @property {Array<WebGLArrayBuffer>} lineStringBuffers Array containing indices and vertices buffers for line strings\n * @property {Array<WebGLArrayBuffer>} pointBuffers Array containing indices and vertices buffers for points\n * @property {import(\"../../transform.js\").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers\n */\n\n/**\n * @typedef {Object} RenderInstructions\n * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render\n * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render\n * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)\n * @property {string} vertex Vertex shader source\n * @property {string} fragment Fragment shader source\n */\n\n/**\n * @typedef {Object} AsShaders\n * @property {import(\"./ShaderBuilder.js\").ShaderBuilder} builder Shader builder with the appropriate presets.\n * @property {AttributeDefinitions} [attributes] Custom attributes made available in the vertex shaders.\n * Default shaders rely on the attributes in {@link Attributes}.\n * @property {UniformDefinitions} [uniforms] Additional uniforms usable in shaders.\n */\n\n/**\n * @typedef {Object} AsRule\n * @property {import('../../style/flat.js').FlatStyle} style Style\n * @property {import(\"../../expr/expression.js\").EncodedExpression} [filter] Filter\n */\n\n/**\n * @typedef {AsRule|AsShaders} VectorStyle\n */\n\n/**\n * @classdesc This class is responsible for:\n * 1. generate WebGL buffers according to a provided style, using a MixedGeometryBatch as input\n * 2. rendering geometries contained in said buffers\n *\n * A layer renderer will typically maintain several of these in order to have several styles rendered separately.\n *\n * A VectorStyleRenderer instance can be created either from a literal style or from shaders using either\n * `VectorStyleRenderer.fromStyle` or `VectorStyleRenderer.fromShaders`. The shaders should not be provided explicitly\n * but instead as a preconfigured ShaderBuilder instance.\n *\n * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the\n * same renderer.\n */\nclass VectorStyleRenderer {\n  /**\n   * @param {VectorStyle} styleOrShaders Literal style or custom shaders\n   * @param {import('../../style/flat.js').StyleVariables} variables Style variables\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {boolean} [enableHitDetection] Whether to enable the hit detection (needs compatible shader)\n   * @param {import(\"../../expr/expression.js\").ExpressionValue} [filter] Optional filter expression\n   */\n  constructor(styleOrShaders, variables, helper, enableHitDetection, filter) {\n    /**\n     * @private\n     * @type {import('../../webgl/Helper.js').default}\n     */\n    this.helper_;\n\n    /**\n     * @private\n     */\n    this.hitDetectionEnabled_ = !!enableHitDetection;\n\n    let asShaders = /** @type {AsShaders} */ (styleOrShaders);\n    const isShaders = 'builder' in styleOrShaders;\n    if (!isShaders) {\n      const asRule = /** @type {AsRule} */ (styleOrShaders);\n      const parseResult = parseLiteralStyle(\n        asRule.style,\n        variables,\n        asRule.filter,\n      );\n      asShaders = {\n        builder: parseResult.builder,\n        attributes: parseResult.attributes,\n        uniforms: parseResult.uniforms,\n      };\n    }\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.fillProgram_;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.strokeProgram_;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.symbolProgram_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = !!asShaders.builder.getFillVertexShader();\n    if (this.hasFill_) {\n      /**\n       * @private\n       */\n      this.fillVertexShader_ = asShaders.builder.getFillVertexShader();\n      /**\n       * @private\n       */\n      this.fillFragmentShader_ = asShaders.builder.getFillFragmentShader();\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = !!asShaders.builder.getStrokeVertexShader();\n    if (this.hasStroke_) {\n      /**\n       * @private\n       */\n      this.strokeVertexShader_ = asShaders.builder.getStrokeVertexShader();\n      /**\n       * @private\n       */\n      this.strokeFragmentShader_ = asShaders.builder.getStrokeFragmentShader();\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = !!asShaders.builder.getSymbolVertexShader();\n    if (this.hasSymbol_) {\n      /**\n       * @private\n       */\n      this.symbolVertexShader_ = asShaders.builder.getSymbolVertexShader();\n      /**\n       * @private\n       */\n      this.symbolFragmentShader_ = asShaders.builder.getSymbolFragmentShader();\n    }\n\n    /**\n     * @type {function(import('../../Feature.js').FeatureLike): boolean}\n     * @private\n     */\n    this.featureFilter_ = null;\n    if (filter) {\n      this.featureFilter_ = this.computeFeatureFilter(filter);\n    }\n\n    const hitDetectionAttributes = this.hitDetectionEnabled_\n      ? {\n          hitColor: {\n            callback() {\n              return colorEncodeId(this.ref, tmpColor);\n            },\n            size: 4,\n          },\n        }\n      : {};\n\n    /**\n     * @private\n     */\n    this.customAttributes_ = Object.assign(\n      {},\n      hitDetectionAttributes,\n      asShaders.attributes,\n    );\n    /**\n     * @private\n     */\n    this.uniforms_ = asShaders.uniforms;\n\n    const customAttributesDesc = Object.entries(this.customAttributes_).map(\n      ([name, value]) => ({\n        name: `a_${name}`,\n        size: value.size || 1,\n        type: AttributeType.FLOAT,\n      }),\n    );\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.polygonAttributesDesc_ = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.lineStringAttributesDesc_ = [\n      {\n        name: Attributes.SEGMENT_START,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.MEASURE_START,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.SEGMENT_END,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.MEASURE_END,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.JOIN_ANGLES,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.DISTANCE,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.PARAMETERS,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.pointAttributesDesc_ = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.INDEX,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n\n    this.setHelper(helper);\n  }\n\n  /**\n   * Will apply the style filter when generating geometry batches (if it can be evaluated outside a map context)\n   * @param {import(\"../../expr/expression.js\").ExpressionValue} filter Style filter\n   * @return {function(import('../../Feature.js').FeatureLike): boolean} Feature filter\n   * @private\n   */\n  computeFeatureFilter(filter) {\n    const parsingContext = newParsingContext();\n    /**\n     * @type {import('../../expr/cpu.js').ExpressionEvaluator}\n     */\n    let compiled;\n    try {\n      compiled = buildExpression(filter, BooleanType, parsingContext);\n    } catch {\n      // filter expression failed to compile for CPU: ignore it\n      return null;\n    }\n\n    // do not apply the filter if it depends on map state (e.g. zoom level) or any variable\n    if (parsingContext.mapState || parsingContext.variables.size > 0) {\n      return null;\n    }\n\n    const evalContext = newEvaluationContext();\n    return (feature) => {\n      evalContext.properties = feature.getPropertiesInternal();\n      if (parsingContext.featureId) {\n        const id = feature.getId();\n        if (id !== undefined) {\n          evalContext.featureId = id;\n        } else {\n          evalContext.featureId = null;\n        }\n      }\n      evalContext.geometryType = computeGeometryType(feature.getGeometry());\n      return /** @type {boolean} */ (compiled(evalContext));\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLBuffers|null>} A promise resolving to WebGL buffers; returns null if buffers are empty\n   */\n  async generateBuffers(geometryBatch, transform) {\n    let filteredBatch = geometryBatch;\n    if (this.featureFilter_) {\n      filteredBatch = filteredBatch.filter(this.featureFilter_);\n      if (filteredBatch.isEmpty()) {\n        return null;\n      }\n    }\n    const renderInstructions = this.generateRenderInstructions_(\n      filteredBatch,\n      transform,\n    );\n    const [polygonBuffers, lineStringBuffers, pointBuffers] = await Promise.all(\n      [\n        this.generateBuffersForType_(\n          renderInstructions.polygonInstructions,\n          'Polygon',\n          transform,\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.lineStringInstructions,\n          'LineString',\n          transform,\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.pointInstructions,\n          'Point',\n          transform,\n        ),\n      ],\n    );\n    // also return the inverse of the transform that was applied when generating buffers\n    const invertVerticesTransform = makeInverseTransform(\n      createTransform(),\n      transform,\n    );\n    return {\n      polygonBuffers: polygonBuffers,\n      lineStringBuffers: lineStringBuffers,\n      pointBuffers: pointBuffers,\n      invertVerticesTransform: invertVerticesTransform,\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {RenderInstructions} Render instructions\n   * @private\n   */\n  generateRenderInstructions_(geometryBatch, transform) {\n    const polygonInstructions = this.hasFill_\n      ? generatePolygonRenderInstructions(\n          geometryBatch.polygonBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n    const lineStringInstructions = this.hasStroke_\n      ? generateLineStringRenderInstructions(\n          geometryBatch.lineStringBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n    const pointInstructions = this.hasSymbol_\n      ? generatePointRenderInstructions(\n          geometryBatch.pointBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform,\n        )\n      : null;\n\n    return {\n      polygonInstructions,\n      lineStringInstructions,\n      pointInstructions,\n    };\n  }\n\n  /**\n   * @param {Float32Array|null} renderInstructions Render instructions\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render\n   * @private\n   */\n  generateBuffersForType_(renderInstructions, geometryType, transform) {\n    if (renderInstructions === null) {\n      return null;\n    }\n\n    const messageId = workerMessageCounter++;\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: renderInstructions.buffer,\n      renderInstructionsTransform: transform,\n      customAttributesSize: getCustomAttributesSize(this.customAttributes_),\n    };\n    const WEBGL_WORKER = getWebGLWorker();\n    WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    renderInstructions = null;\n\n    return new Promise((resolve) => {\n      /**\n       * @param {*} event Event.\n       */\n      const handleMessage = (event) => {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        WEBGL_WORKER.removeEventListener('message', handleMessage);\n\n        // the helper has disposed in the meantime; the promise will not be resolved\n        if (!this.helper_.getGL()) {\n          return;\n        }\n\n        // copy & flush received buffers to GPU\n        const verticesBuffer = new WebGLArrayBuffer(\n          ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.vertexBuffer);\n        const indicesBuffer = new WebGLArrayBuffer(\n          ELEMENT_ARRAY_BUFFER,\n          DYNAMIC_DRAW,\n        ).fromArrayBuffer(received.indexBuffer);\n        this.helper_.flushBufferData(verticesBuffer);\n        this.helper_.flushBufferData(indicesBuffer);\n\n        resolve([indicesBuffer, verticesBuffer]);\n      };\n\n      WEBGL_WORKER.addEventListener('message', handleMessage);\n    });\n  }\n\n  /**\n   * Render the geometries in the given buffers.\n   * @param {WebGLBuffers} buffers WebGL Buffers to draw\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   */\n  render(buffers, frameState, preRenderCallback) {\n    this.hasFill_ &&\n      this.renderInternal_(\n        buffers.polygonBuffers[0],\n        buffers.polygonBuffers[1],\n        this.fillProgram_,\n        this.polygonAttributesDesc_,\n        frameState,\n        preRenderCallback,\n      );\n    this.hasStroke_ &&\n      this.renderInternal_(\n        buffers.lineStringBuffers[0],\n        buffers.lineStringBuffers[1],\n        this.strokeProgram_,\n        this.lineStringAttributesDesc_,\n        frameState,\n        preRenderCallback,\n      );\n    this.hasSymbol_ &&\n      this.renderInternal_(\n        buffers.pointBuffers[0],\n        buffers.pointBuffers[1],\n        this.symbolProgram_,\n        this.pointAttributesDesc_,\n        frameState,\n        preRenderCallback,\n      );\n  }\n\n  /**\n   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer\n   * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer\n   * @param {WebGLProgram} program Program\n   * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   * @private\n   */\n  renderInternal_(\n    indicesBuffer,\n    verticesBuffer,\n    program,\n    attributes,\n    frameState,\n    preRenderCallback,\n  ) {\n    const renderCount = indicesBuffer.getSize();\n    if (renderCount === 0) {\n      return;\n    }\n    this.helper_.useProgram(program, frameState);\n    this.helper_.bindBuffer(verticesBuffer);\n    this.helper_.bindBuffer(indicesBuffer);\n    this.helper_.enableAttributes(attributes);\n    preRenderCallback();\n    this.helper_.drawElements(0, renderCount);\n  }\n\n  /**\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {WebGLBuffers} buffers WebGL Buffers to reload if any\n   */\n  setHelper(helper, buffers = null) {\n    this.helper_ = helper;\n\n    if (this.hasFill_) {\n      this.fillProgram_ = this.helper_.getProgram(\n        this.fillFragmentShader_,\n        this.fillVertexShader_,\n      );\n    }\n    if (this.hasStroke_) {\n      this.strokeProgram_ = this.helper_.getProgram(\n        this.strokeFragmentShader_,\n        this.strokeVertexShader_,\n      );\n    }\n    if (this.hasSymbol_) {\n      this.symbolProgram_ = this.helper_.getProgram(\n        this.symbolFragmentShader_,\n        this.symbolVertexShader_,\n      );\n    }\n    this.helper_.addUniforms(this.uniforms_);\n\n    if (buffers) {\n      if (buffers.polygonBuffers) {\n        this.helper_.flushBufferData(buffers.polygonBuffers[0]);\n        this.helper_.flushBufferData(buffers.polygonBuffers[1]);\n      }\n      if (buffers.lineStringBuffers) {\n        this.helper_.flushBufferData(buffers.lineStringBuffers[0]);\n        this.helper_.flushBufferData(buffers.lineStringBuffers[1]);\n      }\n      if (buffers.pointBuffers) {\n        this.helper_.flushBufferData(buffers.pointBuffers[0]);\n        this.helper_.flushBufferData(buffers.pointBuffers[1]);\n      }\n    }\n  }\n}\n\nexport default VectorStyleRenderer;\n"],"names":["MixedGeometryBatch","features","projectionTransform","feature","geometry","featureUid","getUid","entry","type","geometries","multiPolygonGeom","multiLineGeom","multiPointGeom","polygonGeom","pointGeom","lineGeom","stride","flatCoords","ends","layout","verticesCount","multiPolygonEndss","i","ii","polygonEnds","prevPolygonEnds","startIndex","endIndex","end","multiLineEnds","RenderFeature","multiPolygonEnds","inflateEnds","ringsCount","ringsVerticesCount","ind","arr","getFlatCoordinatesXY","getFlatCoordinatesXYM","currentRef","ref","featureFilter","filtered","empty","v","pushCustomAttributesInRenderInstructions","renderInstructions","customAttributes","batchEntry","currentIndex","shift","key","attr","value","first","UNDEFINED_PROP_VALUE","getCustomAttributesSize","prev","curr","generatePointRenderInstructions","batch","transform","totalInstructionsCount","tmpCoords","renderIndex","applyTransform","generateLineStringRenderInstructions","transform2D","j","jj","generatePolygonRenderInstructions","tmpColor","WEBGL_WORKER","getWebGLWorker","createWebGLWorker","workerMessageCounter","Attributes","VectorStyleRenderer","styleOrShaders","variables","helper","enableHitDetection","filter","asShaders","asRule","parseResult","parseLiteralStyle","hitDetectionAttributes","colorEncodeId","customAttributesDesc","name","AttributeType","parsingContext","newParsingContext","compiled","buildExpression","BooleanType","evalContext","newEvaluationContext","id","computeGeometryType","geometryBatch","filteredBatch","polygonBuffers","lineStringBuffers","pointBuffers","invertVerticesTransform","makeInverseTransform","createTransform","polygonInstructions","lineStringInstructions","pointInstructions","geometryType","messageId","messageType","WebGLWorkerMessageType","message","resolve","handleMessage","event","received","verticesBuffer","WebGLArrayBuffer","ARRAY_BUFFER","DYNAMIC_DRAW","indicesBuffer","ELEMENT_ARRAY_BUFFER","buffers","frameState","preRenderCallback","program","attributes","renderCount"],"mappings":"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","x_google_ignoreList":[0,1,2]}