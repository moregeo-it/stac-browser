{"version":3,"file":"VectorLayer-ChPZ7sy0.js","sources":["../../node_modules/ol/renderer/webgl/VectorLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {assert} from '../../asserts.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport BaseVector from '../../layer/BaseVector.js';\nimport {\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport VectorStyleRenderer from '../../render/webgl/VectorStyleRenderer.js';\nimport {colorDecodeId} from '../../render/webgl/encodeUtil.js';\nimport {breakDownFlatStyle} from '../../render/webgl/style.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  setFromArray as setFromTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {getWorldParameters} from './worldUtil.js';\n\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n};\n\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').AsShaders} StyleAsShaders\n */\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').AsRule} StyleAsRule\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {import('../../style/flat.js').FlatStyleLike | Array<StyleAsShaders> | StyleAsShaders} style Flat vector style; also accepts shaders\n * @property {Object<string, number|Array<number>|string|boolean>} variables Style variables\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  Polygons are broken down into triangles\n *  Lines are rendered as strips of quads\n *  Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = {\n      [Uniforms.RENDER_EXTENT]: [0, 0, 0, 0],\n      [Uniforms.PATTERN_ORIGIN]: [0, 0],\n      [Uniforms.GLOBAL_ALPHA]: 1,\n    };\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = !options.disableHitDetection;\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = createTransform();\n\n    /**\n     * @private\n     */\n    this.tmpCoords_ = [0, 0];\n    /**\n     * @private\n     */\n    this.tmpTransform_ = createTransform();\n    /**\n     * @private\n     */\n    this.tmpMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    /**\n     * @type {import('../../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = {};\n\n    /**\n     * @type {Array<StyleAsRule | StyleAsShaders>}\n     * @private\n     */\n    this.styles_ = [];\n\n    /**\n     * @type {Array<VectorStyleRenderer>}\n     * @private\n     */\n    this.styleRenderers_ = [];\n\n    /**\n     * @type {Array<import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers>}\n     * @private\n     */\n    this.buffers_ = [];\n\n    this.applyOptions_(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.initialFeaturesAdded_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../events.js\").EventsKey|null>}\n     */\n    this.sourceListenKeys_ = null;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  addInitialFeatures_(frameState) {\n    const source = this.getLayer().getSource();\n    const userProjection = getUserProjection();\n    let projectionTransform;\n    if (userProjection) {\n      projectionTransform = getTransformFromProjections(\n        userProjection,\n        frameState.viewState.projection,\n      );\n    }\n    this.batch_.addFeatures(source.getFeatures(), projectionTransform);\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_.bind(this, projectionTransform),\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_.bind(this, projectionTransform),\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.styleVariables_ = options.variables;\n    this.styles_ = breakDownFlatStyle(options.style);\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.buffers_ = [];\n    this.styleRenderers_ = this.styles_.map(\n      (style) =>\n        new VectorStyleRenderer(\n          style,\n          this.styleVariables_,\n          this.helper,\n          this.hitDetectionEnabled_,\n          'filter' in style ? style.filter : null,\n        ),\n    );\n  }\n\n  /**\n   * @override\n   */\n  reset(options) {\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n    super.reset(options);\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    if (this.styleRenderers_.length) {\n      // To reuse buffers\n      this.styleRenderers_.forEach((renderer, i) =>\n        renderer.setHelper(this.helper, this.buffers_[i]),\n      );\n    } else {\n      this.createRenderers_();\n    }\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed\n   * @private\n   */\n  applyUniforms_(batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(\n      Uniforms.PROJECTION_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_),\n    );\n\n    // screen to world matrix\n    makeInverseTransform(this.tmpTransform_, this.tmpTransform_);\n    this.helper.setUniformMatrixValue(\n      Uniforms.SCREEN_TO_WORLD_MATRIX,\n      mat4FromTransform(this.tmpMat4_, this.tmpTransform_),\n    );\n\n    // pattern origin should always be [0, 0] in world coordinates\n    this.tmpCoords_[0] = 0;\n    this.tmpCoords_[1] = 0;\n    makeInverseTransform(this.tmpTransform_, batchInvertTransform);\n    applyTransform(this.tmpTransform_, this.tmpCoords_);\n    this.helper.setUniformFloatVec2(Uniforms.PATTERN_ORIGIN, this.tmpCoords_);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.helper.prepareDraw(frameState);\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.initialFeaturesAdded_) {\n      this.addInitialFeatures_(frameState);\n      this.initialFeaturesAdded_ = true;\n    }\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        vectorSource.loadFeatures(\n          toUserExtent(extent, userProjection),\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      } else {\n        vectorSource.loadFeatures(extent, resolution, projection);\n      }\n\n      this.ready = false;\n\n      const transform = this.helper.makeProjectionTransform(\n        frameState,\n        createTransform(),\n      );\n\n      const generatePromises = this.styleRenderers_.map((renderer, i) =>\n        renderer.generateBuffers(this.batch_, transform).then((buffers) => {\n          if (this.buffers_[i]) {\n            this.disposeBuffers(this.buffers_[i]);\n          }\n          this.buffers_[i] = buffers;\n        }),\n      );\n      Promise.all(generatePromises).then(() => {\n        this.ready = true;\n        this.getLayer().changed();\n      });\n\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    return true;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    do {\n      this.helper.makeProjectionTransform(\n        frameState,\n        this.currentFrameStateTransform_,\n      );\n      translateTransform(\n        this.currentFrameStateTransform_,\n        world * worldWidth,\n        0,\n      );\n      for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {\n        const renderer = this.styleRenderers_[i];\n        const buffers = this.buffers_[i];\n        if (!buffers) {\n          continue;\n        }\n        renderer.render(buffers, frameState, () => {\n          this.applyUniforms_(buffers.invertVerticesTransform);\n          this.helper.applyHitDetectionUniform(forHitDetection);\n        });\n      }\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.styleRenderers_.length || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const ref = colorDecodeId(color);\n    const feature = this.batch_.getFeatureFromRef(ref);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Will release a set of Webgl buffers\n   * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers\n   */\n  disposeBuffers(buffers) {\n    /**\n     * @param {Array<import('../../webgl/Buffer.js').default>} typeBuffers Buffers\n     */\n    const disposeBuffersOfType = (typeBuffers) => {\n      for (const buffer of typeBuffers) {\n        if (buffer) {\n          this.helper.deleteBuffer(buffer);\n        }\n      }\n    };\n    if (buffers.pointBuffers) {\n      disposeBuffersOfType(buffers.pointBuffers);\n    }\n    if (buffers.lineStringBuffers) {\n      disposeBuffersOfType(buffers.lineStringBuffers);\n    }\n    if (buffers.polygonBuffers) {\n      disposeBuffersOfType(buffers.polygonBuffers);\n    }\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.buffers_.forEach((buffers) => {\n      if (buffers) {\n        this.disposeBuffers(buffers);\n      }\n    });\n    if (this.sourceListenKeys_) {\n      this.sourceListenKeys_.forEach(function (key) {\n        unlistenByKey(key);\n      });\n      this.sourceListenKeys_ = null;\n    }\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLVectorLayerRenderer;\n"],"names":["Uniforms","DefaultUniform","WebGLVectorLayerRenderer","WebGLLayerRenderer","layer","options","uniforms","createEmpty","createTransform","createMat4","MixedGeometryBatch","frameState","source","projectionTransform","listen","VectorEventType","breakDownFlatStyle","style","VectorStyleRenderer","renderer","i","WebGLRenderTarget","event","feature","batchInvertTransform","setFromTransform","multiplyTransform","mat4FromTransform","makeInverseTransform","applyTransform","gl","startWorld","endWorld","worldWidth","getWorldParameters","canvas","vectorSource","viewState","viewNotMoving","ViewHint","extentChanged","equals","sourceChanged","projection","resolution","renderBuffer","BaseVector","extent","buffer","transform","generatePromises","buffers","forHitDetection","world","translateTransform","ii","coordinate","hitTolerance","callback","matches","assert","pixel","data","color","ref","colorDecodeId","disposeBuffersOfType","typeBuffers","key","unlistenByKey"],"mappings":"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","x_google_ignoreList":[0]}