import{g as _,bo as L,bq as v,c5 as A,y as k,c6 as G,aQ as D,aW as I,c1 as N,c7 as M,o as O,p as w}from"./GeoJSON-dVJCj0SI.js";import{m as F,o as p,a as T,b as x,p as b,E as V}from"./compileUtil-DE-8w3AG.js";import{p as z,a as j,d as S,e as W}from"./RenderTarget-Dp0EIh_t.js";class C{constructor(){this.globalCounter_=0,this.refToFeature_=new Map,this.uidToRef_=new Map,this.freeGlobalRef_=[],this.polygonBatch={entries:{},geometriesCount:0,verticesCount:0,ringsCount:0},this.pointBatch={entries:{},geometriesCount:0},this.lineStringBatch={entries:{},geometriesCount:0,verticesCount:0}}addFeatures(e,t){for(let i=0;i<e.length;i++)this.addFeature(e[i],t)}addFeature(e,t){let i=e.getGeometry();i&&(t&&(i=i.clone(),i.applyTransform(t)),this.addGeometry_(i,e))}clearFeatureEntryInPointBatch_(e){const t=_(e),i=this.pointBatch.entries[t];if(i)return this.pointBatch.geometriesCount-=i.flatCoordss.length,delete this.pointBatch.entries[t],i}clearFeatureEntryInLineStringBatch_(e){const t=_(e),i=this.lineStringBatch.entries[t];if(i)return this.lineStringBatch.verticesCount-=i.verticesCount,this.lineStringBatch.geometriesCount-=i.flatCoordss.length,delete this.lineStringBatch.entries[t],i}clearFeatureEntryInPolygonBatch_(e){const t=_(e),i=this.polygonBatch.entries[t];if(i)return this.polygonBatch.verticesCount-=i.verticesCount,this.polygonBatch.ringsCount-=i.ringsCount,this.polygonBatch.geometriesCount-=i.flatCoordss.length,delete this.polygonBatch.entries[t],i}addGeometry_(e,t){const i=e.getType();switch(i){case"GeometryCollection":{const n=e.getGeometriesArray();for(const s of n)this.addGeometry_(s,t);break}case"MultiPolygon":{const n=e;this.addCoordinates_(i,n.getFlatCoordinates(),n.getEndss(),t,_(t),n.getStride());break}case"MultiLineString":{const n=e;this.addCoordinates_(i,n.getFlatCoordinates(),n.getEnds(),t,_(t),n.getStride());break}case"MultiPoint":{const n=e;this.addCoordinates_(i,n.getFlatCoordinates(),null,t,_(t),n.getStride());break}case"Polygon":{const n=e;this.addCoordinates_(i,n.getFlatCoordinates(),n.getEnds(),t,_(t),n.getStride());break}case"Point":{const n=e;this.addCoordinates_(i,n.getFlatCoordinates(),null,t,_(t),n.getStride());break}case"LineString":case"LinearRing":{const n=e,s=n.getStride();this.addCoordinates_(i,n.getFlatCoordinates(),null,t,_(t),s,n.getLayout?.());break}}}addCoordinates_(e,t,i,n,s,r,c){let l;switch(e){case"MultiPolygon":{const o=i;for(let g=0,h=o.length;g<h;g++){let u=o[g];const f=g>0?o[g-1]:null,m=f?f[f.length-1]:0,R=u[u.length-1];u=m>0?u.map(P=>P-m):u,this.addCoordinates_("Polygon",t.slice(m,R),u,n,s,r,c)}break}case"MultiLineString":{const o=i;for(let g=0,h=o.length;g<h;g++){const u=g>0?o[g-1]:0;this.addCoordinates_("LineString",t.slice(u,o[g]),null,n,s,r,c)}break}case"MultiPoint":for(let o=0,g=t.length;o<g;o+=r)this.addCoordinates_("Point",t.slice(o,o+2),null,n,s,null,null);break;case"Polygon":{const o=i;if(n instanceof L){const u=v(t,o);if(u.length>1){this.addCoordinates_("MultiPolygon",t,u,n,s,r,c);return}}this.polygonBatch.entries[s]||(this.polygonBatch.entries[s]=this.addRefToEntry_(s,{feature:n,flatCoordss:[],verticesCount:0,ringsCount:0,ringsVerticesCounts:[]})),l=t.length/r;const g=i.length,h=i.map((u,f,m)=>f>0?(u-m[f-1])/r:u/r);this.polygonBatch.verticesCount+=l,this.polygonBatch.ringsCount+=g,this.polygonBatch.geometriesCount++,this.polygonBatch.entries[s].flatCoordss.push(Y(t,r)),this.polygonBatch.entries[s].ringsVerticesCounts.push(h),this.polygonBatch.entries[s].verticesCount+=l,this.polygonBatch.entries[s].ringsCount+=g;for(let u=0,f=o.length;u<f;u++){const m=u>0?o[u-1]:0;this.addCoordinates_("LinearRing",t.slice(m,o[u]),null,n,s,r,c)}break}case"Point":this.pointBatch.entries[s]||(this.pointBatch.entries[s]=this.addRefToEntry_(s,{feature:n,flatCoordss:[]})),this.pointBatch.geometriesCount++,this.pointBatch.entries[s].flatCoordss.push(t);break;case"LineString":case"LinearRing":this.lineStringBatch.entries[s]||(this.lineStringBatch.entries[s]=this.addRefToEntry_(s,{feature:n,flatCoordss:[],verticesCount:0})),l=t.length/r,this.lineStringBatch.verticesCount+=l,this.lineStringBatch.geometriesCount++,this.lineStringBatch.entries[s].flatCoordss.push(X(t,r,c)),this.lineStringBatch.entries[s].verticesCount+=l;break}}addRefToEntry_(e,t){const i=this.uidToRef_.get(e),n=i||this.freeGlobalRef_.pop()||++this.globalCounter_;return t.ref=n,i||(this.refToFeature_.set(n,t.feature),this.uidToRef_.set(e,n)),t}removeRef_(e,t){if(!e)throw new Error("This feature has no ref: "+t);this.refToFeature_.delete(e),this.uidToRef_.delete(t),this.freeGlobalRef_.push(e)}changeFeature(e,t){if(!this.uidToRef_.get(_(e)))return;this.removeFeature(e);let i=e.getGeometry();i&&(t&&(i=i.clone(),i.applyTransform(t)),this.addGeometry_(i,e))}removeFeature(e){let t=this.clearFeatureEntryInPointBatch_(e);t=this.clearFeatureEntryInPolygonBatch_(e)||t,t=this.clearFeatureEntryInLineStringBatch_(e)||t,t&&this.removeRef_(t.ref,_(t.feature))}clear(){this.polygonBatch.entries={},this.polygonBatch.geometriesCount=0,this.polygonBatch.verticesCount=0,this.polygonBatch.ringsCount=0,this.lineStringBatch.entries={},this.lineStringBatch.geometriesCount=0,this.lineStringBatch.verticesCount=0,this.pointBatch.entries={},this.pointBatch.geometriesCount=0,this.globalCounter_=0,this.freeGlobalRef_=[],this.refToFeature_.clear(),this.uidToRef_.clear()}getFeatureFromRef(e){return this.refToFeature_.get(e)}isEmpty(){return this.globalCounter_===0}filter(e){const t=new C;t.globalCounter_=this.globalCounter_,t.uidToRef_=this.uidToRef_,t.refToFeature_=this.refToFeature_;let i=!0;for(const n of this.refToFeature_.values())e(n)&&(t.addFeature(n),i=!1);return i?new C:t}}function Y(a,e){return e===2?a:a.filter((t,i)=>i%e<2)}function X(a,e,t){return e===3&&t==="XYM"?a:e===4?a.filter((i,n)=>n%e!==2):e===3?a.map((i,n)=>n%e!==2?i:0):new Array(a.length*1.5).fill(0).map((i,n)=>n%3===2?0:a[Math.round(n/1.5)])}function E(a,e,t,i){let n=0;for(const s in e){const r=e[s],c=r.callback.call(t,t.feature);let l=c?.[0]??c;l===F&&console.warn('The "has" operator might return false positives.'),l===void 0?l=F:l===null&&(l=0),a[i+n++]=l,!(!r.size||r.size===1)&&(a[i+n++]=c[1],!(r.size<3)&&(a[i+n++]=c[2],!(r.size<4)&&(a[i+n++]=c[3])))}return n}function y(a){return Object.keys(a).reduce((e,t)=>e+(a[t].size||1),0)}function H(a,e,t,i){const n=(2+y(t))*a.geometriesCount;(!e||e.length!==n)&&(e=new Float32Array(n));const s=[];let r=0;for(const c in a.entries){const l=a.entries[c];for(let o=0,g=l.flatCoordss.length;o<g;o++)s[0]=l.flatCoordss[o][0],s[1]=l.flatCoordss[o][1],k(i,s),e[r++]=s[0],e[r++]=s[1],r+=E(e,t,l,r)}return e}function J(a,e,t,i){const n=3*a.verticesCount+(1+y(t))*a.geometriesCount;(!e||e.length!==n)&&(e=new Float32Array(n));const s=[];let r=0;for(const c in a.entries){const l=a.entries[c];for(let o=0,g=l.flatCoordss.length;o<g;o++){s.length=l.flatCoordss[o].length,A(l.flatCoordss[o],0,s.length,3,i,s,3),r+=E(e,t,l,r),e[r++]=s.length/3;for(let h=0,u=s.length;h<u;h+=3)e[r++]=s[h],e[r++]=s[h+1],e[r++]=s[h+2]}}return e}function K(a,e,t,i){const n=2*a.verticesCount+(1+y(t))*a.geometriesCount+a.ringsCount;(!e||e.length!==n)&&(e=new Float32Array(n));const s=[];let r=0;for(const c in a.entries){const l=a.entries[c];for(let o=0,g=l.flatCoordss.length;o<g;o++){s.length=l.flatCoordss[o].length,A(l.flatCoordss[o],0,s.length,2,i,s),r+=E(e,t,l,r),e[r++]=l.ringsVerticesCounts[o].length;for(let h=0,u=l.ringsVerticesCounts[o].length;h<u;h++)e[r++]=l.ringsVerticesCounts[o][h];for(let h=0,u=s.length;h<u;h+=2)e[r++]=s[h],e[r++]=s[h+1]}}return e}const $=[];let B;function q(){return B||(B=W()),B}let Q=0;const d={POSITION:"a_position",INDEX:"a_index",SEGMENT_START:"a_segmentStart",SEGMENT_END:"a_segmentEnd",MEASURE_START:"a_measureStart",MEASURE_END:"a_measureEnd",PARAMETERS:"a_parameters",JOIN_ANGLES:"a_joinAngles",DISTANCE:"a_distance"};class et{constructor(e,t,i,n,s){this.helper_,this.hitDetectionEnabled_=!!n;let r=e;if(!("builder"in e)){const g=e,h=z(g.style,t,g.filter);r={builder:h.builder,attributes:h.attributes,uniforms:h.uniforms}}this.fillProgram_,this.strokeProgram_,this.symbolProgram_,this.hasFill_=!!r.builder.getFillVertexShader(),this.hasFill_&&(this.fillVertexShader_=r.builder.getFillVertexShader(),this.fillFragmentShader_=r.builder.getFillFragmentShader()),this.hasStroke_=!!r.builder.getStrokeVertexShader(),this.hasStroke_&&(this.strokeVertexShader_=r.builder.getStrokeVertexShader(),this.strokeFragmentShader_=r.builder.getStrokeFragmentShader()),this.hasSymbol_=!!r.builder.getSymbolVertexShader(),this.hasSymbol_&&(this.symbolVertexShader_=r.builder.getSymbolVertexShader(),this.symbolFragmentShader_=r.builder.getSymbolFragmentShader()),this.featureFilter_=null,s&&(this.featureFilter_=this.computeFeatureFilter(s));const l=this.hitDetectionEnabled_?{hitColor:{callback(){return j(this.ref,$)},size:4}}:{};this.customAttributes_=Object.assign({},l,r.attributes),this.uniforms_=r.uniforms;const o=Object.entries(this.customAttributes_).map(([g,h])=>({name:`a_${g}`,size:h.size||1,type:p.FLOAT}));this.polygonAttributesDesc_=[{name:d.POSITION,size:2,type:p.FLOAT},...o],this.lineStringAttributesDesc_=[{name:d.SEGMENT_START,size:2,type:p.FLOAT},{name:d.MEASURE_START,size:1,type:p.FLOAT},{name:d.SEGMENT_END,size:2,type:p.FLOAT},{name:d.MEASURE_END,size:1,type:p.FLOAT},{name:d.JOIN_ANGLES,size:2,type:p.FLOAT},{name:d.DISTANCE,size:1,type:p.FLOAT},{name:d.PARAMETERS,size:1,type:p.FLOAT},...o],this.pointAttributesDesc_=[{name:d.POSITION,size:2,type:p.FLOAT},{name:d.INDEX,size:1,type:p.FLOAT},...o],this.setHelper(i)}computeFeatureFilter(e){const t=I();let i;try{i=G(e,D,t)}catch{return null}if(t.mapState||t.variables.size>0)return null;const n=M();return s=>{if(n.properties=s.getPropertiesInternal(),t.featureId){const r=s.getId();r!==void 0?n.featureId=r:n.featureId=null}return n.geometryType=N(s.getGeometry()),i(n)}}async generateBuffers(e,t){let i=e;if(this.featureFilter_&&(i=i.filter(this.featureFilter_),i.isEmpty()))return null;const n=this.generateRenderInstructions_(i,t),[s,r,c]=await Promise.all([this.generateBuffersForType_(n.polygonInstructions,"Polygon",t),this.generateBuffersForType_(n.lineStringInstructions,"LineString",t),this.generateBuffersForType_(n.pointInstructions,"Point",t)]),l=O(w(),t);return{polygonBuffers:s,lineStringBuffers:r,pointBuffers:c,invertVerticesTransform:l}}generateRenderInstructions_(e,t){const i=this.hasFill_?K(e.polygonBatch,new Float32Array(0),this.customAttributes_,t):null,n=this.hasStroke_?J(e.lineStringBatch,new Float32Array(0),this.customAttributes_,t):null,s=this.hasSymbol_?H(e.pointBatch,new Float32Array(0),this.customAttributes_,t):null;return{polygonInstructions:i,lineStringInstructions:n,pointInstructions:s}}generateBuffersForType_(e,t,i){if(e===null)return null;const n=Q++;let s;switch(t){case"Polygon":s=S.GENERATE_POLYGON_BUFFERS;break;case"LineString":s=S.GENERATE_LINE_STRING_BUFFERS;break;case"Point":s=S.GENERATE_POINT_BUFFERS;break}const r={id:n,type:s,renderInstructions:e.buffer,renderInstructionsTransform:i,customAttributesSize:y(this.customAttributes_)},c=q();return c.postMessage(r,[e.buffer]),e=null,new Promise(l=>{const o=g=>{const h=g.data;if(h.id!==n||(c.removeEventListener("message",o),!this.helper_.getGL()))return;const u=new T(x,b).fromArrayBuffer(h.vertexBuffer),f=new T(V,b).fromArrayBuffer(h.indexBuffer);this.helper_.flushBufferData(u),this.helper_.flushBufferData(f),l([f,u])};c.addEventListener("message",o)})}render(e,t,i){this.hasFill_&&this.renderInternal_(e.polygonBuffers[0],e.polygonBuffers[1],this.fillProgram_,this.polygonAttributesDesc_,t,i),this.hasStroke_&&this.renderInternal_(e.lineStringBuffers[0],e.lineStringBuffers[1],this.strokeProgram_,this.lineStringAttributesDesc_,t,i),this.hasSymbol_&&this.renderInternal_(e.pointBuffers[0],e.pointBuffers[1],this.symbolProgram_,this.pointAttributesDesc_,t,i)}renderInternal_(e,t,i,n,s,r){const c=e.getSize();c!==0&&(this.helper_.useProgram(i,s),this.helper_.bindBuffer(t),this.helper_.bindBuffer(e),this.helper_.enableAttributes(n),r(),this.helper_.drawElements(0,c))}setHelper(e,t=null){this.helper_=e,this.hasFill_&&(this.fillProgram_=this.helper_.getProgram(this.fillFragmentShader_,this.fillVertexShader_)),this.hasStroke_&&(this.strokeProgram_=this.helper_.getProgram(this.strokeFragmentShader_,this.strokeVertexShader_)),this.hasSymbol_&&(this.symbolProgram_=this.helper_.getProgram(this.symbolFragmentShader_,this.symbolVertexShader_)),this.helper_.addUniforms(this.uniforms_),t&&(t.polygonBuffers&&(this.helper_.flushBufferData(t.polygonBuffers[0]),this.helper_.flushBufferData(t.polygonBuffers[1])),t.lineStringBuffers&&(this.helper_.flushBufferData(t.lineStringBuffers[0]),this.helper_.flushBufferData(t.lineStringBuffers[1])),t.pointBuffers&&(this.helper_.flushBufferData(t.pointBuffers[0]),this.helper_.flushBufferData(t.pointBuffers[1])))}}export{C as M,et as V};
//# sourceMappingURL=VectorStyleRenderer-W9NXHFGV.js.map
