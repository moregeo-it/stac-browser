import{D as ce,a as le}from"./DataTile-B7a7Je00.js";import{I as xe,R as ye}from"./Tile-C6wKdysJ.js";import{T as Re}from"./TileRange-2Tc-Ry00.js";import{aw as Ce,am as me,y as ae,az as ve,f as P,a2 as Se,g as I,aE as we,ax as N,v as H,aC as _e,a7 as Ee,a1 as Ke,Y as je,X as Le}from"./GeoJSON-dVJCj0SI.js";import{L as Pe}from"./LRUCache-D3qbVE6m.js";import{c as de,g as De}from"./tilecoord-CR7vLr2I.js";function W(x,e,t,i,o){return`${I(x)},${e},${De(t,i,o)}`}function $(x,e,t){if(!(t in x))return x[t]=new Set([e]),!0;const i=x[t],o=i.has(e);return o||i.add(e),!o}function Fe(x,e,t){const i=x[t];return i?i.delete(e):!1}function he(x,e){const t=x.layerStatesArray[x.layerIndex];t.extent&&(e=H(e,N(t.extent,x.viewState.projection)));const i=t.layer.getRenderSource();if(!i.getWrapX()){const o=i.getTileGridForProjection(x.viewState.projection).getExtent();o&&(e=H(e,o))}return e}class ke extends Ce{constructor(e,t){super(e),t=t||{},this.extentChanged=!0,this.renderComplete=!1,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedTiles=[],this.renderedSourceKey_,this.renderedSourceRevision_,this.tempExtent=me(),this.tempTileRange_=new Re(0,0,0,0),this.tempTileCoord_=de(0,0,0);const i=t.cacheSize!==void 0?t.cacheSize:512;this.tileCache_=new Pe(i),this.maxStaleKeys=i*.5}getTileCache(){return this.tileCache_}getOrCreateTile(e,t,i,o){const l=this.tileCache_,c=this.getLayer().getSource(),r=W(c,c.getKey(),e,t,i);let s;if(l.containsKey(r))s=l.get(r);else{if(s=c.getTile(e,t,i,o.pixelRatio,o.viewState.projection),!s)return null;l.set(r,s)}return s}getTile(e,t,i,o){const l=this.getOrCreateTile(e,t,i,o);return l||null}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),o=ae(t.pixelToCoordinateTransform,e.slice()),l=i.getExtent();if(l&&!ve(l,o))return null;const u=t.viewState,c=i.getRenderSource(),r=c.getTileGridForProjection(u.projection),s=c.getTilePixelRatio(t.pixelRatio);for(let n=r.getZForResolution(u.resolution);n>=r.getMinZoom();--n){const d=r.getTileCoordForCoordAndZ(o,n),a=this.getTile(n,d[1],d[2],t);if(!a||a.getState()!==P.LOADED)continue;const g=r.getOrigin(n),f=Se(r.getTileSize(n)),w=r.getResolution(n);let h;if(a instanceof xe||a instanceof ye)h=a.getImage();else if(a instanceof ce){if(h=le(a.getData()),!h)continue}else continue;const v=Math.floor(s*((o[0]-g[0])/w-d[1]*f[0])),D=Math.floor(s*((g[1]-o[1])/w-d[2]*f[1])),m=Math.round(s*c.getGutterForProjection(u.projection));return this.getImageData(h,v+m,D+m)}return null}prepareFrame(e){this.renderedProjection?e.viewState.projection!==this.renderedProjection&&(this.tileCache_.clear(),this.renderedProjection=e.viewState.projection):this.renderedProjection=e.viewState.projection;const t=this.getLayer().getSource();if(!t)return!1;const i=t.getRevision();return this.renderedSourceRevision_?this.renderedSourceRevision_!==i&&(this.renderedSourceRevision_=i,this.renderedSourceKey_===t.getKey()&&this.tileCache_.clear()):this.renderedSourceRevision_=i,!0}enqueueTiles(e,t,i,o,l){const u=e.viewState,c=this.getLayer(),r=c.getRenderSource(),s=r.getTileGridForProjection(u.projection),n=I(r);n in e.wantedTiles||(e.wantedTiles[n]={});const d=e.wantedTiles[n],a=c.getMapInternal(),g=Math.max(i-l,s.getMinZoom(),s.getZForResolution(Math.min(c.getMaxResolution(),a?a.getView().getResolutionForZoom(Math.max(c.getMinZoom(),0)):s.getResolution(0)),r.zDirection)),f=u.rotation,w=f?we(u.center,u.resolution,f,e.size):void 0;for(let h=i;h>=g;--h){const v=s.getTileRangeForExtentAndZ(t,h,this.tempTileRange_),D=s.getResolution(h);for(let m=v.minX;m<=v.maxX;++m)for(let _=v.minY;_<=v.maxY;++_){if(f&&!s.tileCoordIntersectsViewport([h,m,_],w))continue;const E=this.getTile(h,m,_,e);if(!E||!$(o,E,h))continue;const T=E.getKey();if(d[T]=!0,E.getState()===P.IDLE&&!e.tileQueue.isKeyQueued(T)){const Z=de(h,m,_,this.tempTileCoord_);e.tileQueue.enqueue([E,n,s.getTileCoordCenter(Z),D])}}}}findStaleTile_(e,t){const i=this.tileCache_,o=e[0],l=e[1],u=e[2],c=this.getStaleKeys();for(let r=0;r<c.length;++r){const s=W(this.getLayer().getSource(),c[r],o,l,u);if(i.containsKey(s)){const n=i.peek(s);if(n.getState()===P.LOADED)return n.endTransition(I(this)),$(t,n,o),!0}}return!1}findAltTiles_(e,t,i,o){const l=e.getTileRangeForTileCoordAndZ(t,i,this.tempTileRange_);if(!l)return!1;let u=!0;const c=this.tileCache_,r=this.getLayer().getRenderSource(),s=r.getKey();for(let n=l.minX;n<=l.maxX;++n)for(let d=l.minY;d<=l.maxY;++d){const a=W(r,s,i,n,d);let g=!1;if(c.containsKey(a)){const f=c.peek(a);f.getState()===P.LOADED&&($(o,f,i),g=!0)}g||(u=!1)}return u}renderFrame(e,t){this.renderComplete=!0;const i=e.layerStatesArray[e.layerIndex],o=e.viewState,l=o.projection,u=o.resolution,c=o.center,r=e.pixelRatio,s=this.getLayer(),n=s.getSource(),d=n.getTileGridForProjection(l),a=d.getZForResolution(u,n.zDirection),g=d.getResolution(a),f=n.getKey();this.renderedSourceKey_?this.renderedSourceKey_!==f&&(this.prependStaleKey(this.renderedSourceKey_),this.renderedSourceKey_=f):this.renderedSourceKey_=f;let w=e.extent;const h=n.getTilePixelRatio(r);this.prepareContainer(e,t);const v=this.context.canvas.width,D=this.context.canvas.height,m=i.extent&&N(i.extent);m&&(w=H(w,N(i.extent)));const _=g*v/2/h,E=g*D/2/h,M=[c[0]-_,c[1]-E,c[0]+_,c[1]+E],T={};this.renderedTiles.length=0;const Z=s.getPreload();if(e.nextExtent){const y=d.getZForResolution(o.nextResolution,n.zDirection),R=he(e,e.nextExtent);this.enqueueTiles(e,R,y,T,Z)}const J=he(e,w);if(this.enqueueTiles(e,J,a,T,0),Z>0&&setTimeout(()=>{this.enqueueTiles(e,J,a-1,T,Z-1)},0),!(a in T))return this.container;const ee=I(this),ue=e.time;for(const y of T[a]){const R=y.getState();if(R===P.EMPTY)continue;const K=y.tileCoord;if(R===P.LOADED&&y.getAlpha(ee,ue)===1){y.endTransition(ee);continue}if(R!==P.ERROR&&(this.renderComplete=!1),this.findStaleTile_(K,T)){Fe(T,y,a),e.animate=!0;continue}if(this.findAltTiles_(d,K,a+1,T))continue;const z=d.getMinZoom();for(let F=a-1;F>=z&&!this.findAltTiles_(d,K,F,T);--F);}const k=g/u*r/h,p=this.getRenderContext(e);_e(this.tempTransform,v/2,D/2,k,k,0,-v/2,-D/2),i.extent&&this.clipUnrotated(p,e,m),n.getInterpolate()||(p.imageSmoothingEnabled=!1),this.preRender(p,e);const G=Object.keys(T).map(Number);G.sort(Ee);let S;const Q=[],te=[];for(let y=G.length-1;y>=0;--y){const R=G[y],K=n.getTilePixelSize(R,r,l),A=d.getResolution(R)/g,z=K[0]*A*k,F=K[1]*A*k,b=d.getTileCoordForCoordAndZ(Ke(M),R),ie=d.getTileCoordExtent(b),X=ae(this.tempTransform,[h*(ie[0]-M[0])/g,h*(M[3]-ie[3])/g]),ge=h*n.getGutterForProjection(l);for(const O of T[R]){if(O.getState()!==P.LOADED)continue;const ne=O.tileCoord,oe=b[1]-ne[1],pe=Math.round(X[0]-(oe-1)*z),se=b[2]-ne[2],fe=Math.round(X[1]-(se-1)*F),j=Math.round(X[0]-oe*z),L=Math.round(X[1]-se*F),Y=pe-j,U=fe-L,re=G.length===1;let V=!1;S=[j,L,j+Y,L,j+Y,L+U,j,L+U];for(let q=0,Te=Q.length;q<Te;++q)if(!re&&R<te[q]){const C=Q[q];je([j,L,j+Y,L+U],[C[0],C[3],C[4],C[7]])&&(V||(p.save(),V=!0),p.beginPath(),p.moveTo(S[0],S[1]),p.lineTo(S[2],S[3]),p.lineTo(S[4],S[5]),p.lineTo(S[6],S[7]),p.moveTo(C[6],C[7]),p.lineTo(C[4],C[5]),p.lineTo(C[2],C[3]),p.lineTo(C[0],C[1]),p.clip())}Q.push(S),te.push(R),this.drawTile(O,e,j,L,Y,U,ge,re),V&&p.restore(),this.renderedTiles.unshift(O),this.updateUsedTiles(e.usedTiles,n,O)}}if(this.renderedResolution=g,this.extentChanged=!this.renderedExtent_||!Le(this.renderedExtent_,M),this.renderedExtent_=M,this.renderedPixelRatio=r,this.postRender(this.context,e),i.extent&&p.restore(),p.imageSmoothingEnabled=!0,this.renderComplete){const y=(R,K)=>{const B=I(n),A=K.wantedTiles[B],z=A?Object.keys(A).length:0;this.updateCacheSize(z),this.tileCache_.expireCache()};e.postRenderFunctions.push(y)}return this.container}updateCacheSize(e){this.tileCache_.highWaterMark=Math.max(this.tileCache_.highWaterMark,e*2)}drawTile(e,t,i,o,l,u,c,r){let s;if(e instanceof ce){if(s=le(e.getData()),!s)throw new Error("Rendering array data is not yet supported")}else s=this.getTileImage(e);if(!s)return;const n=this.getRenderContext(t),d=I(this),a=t.layerStatesArray[t.layerIndex],g=a.opacity*(r?e.getAlpha(d,t.time):1),f=g!==n.globalAlpha;f&&(n.save(),n.globalAlpha=g),n.drawImage(s,c,c,s.width-2*c,s.height-2*c,i,o,l,u),f&&n.restore(),g!==a.opacity?t.animate=!0:r&&e.endTransition(d)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}updateUsedTiles(e,t,i){const o=I(t);o in e||(e[o]={}),e[o][i.getKey()]=!0}}export{ke as C};
//# sourceMappingURL=TileLayer-Co3HYvfJ.js.map
