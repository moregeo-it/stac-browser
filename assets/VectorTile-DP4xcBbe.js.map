{"version":3,"file":"VectorTile-DP4xcBbe.js","sources":["../../node_modules/ol/renderer/canvas/VectorTileLayer.js","../../node_modules/ol/layer/VectorTile.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ascending} from '../../array.js';\nimport {wrapX} from '../../coordinate.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {toSize} from '../../size.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(layer);\n    const declutter = layer.getDeclutter();\n    const declutteredFeatures = declutter\n      ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n      : null;\n    let found;\n    foundFeature: for (let i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const executorGroups = tile.executorGroups[layerUid];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        found = executorGroups[t].forEachFeatureAtCoordinate(\n          coordinate,\n          resolution,\n          rotation,\n          hitTolerance,\n          featureCallback,\n          declutteredFeatures,\n        );\n        if (found) {\n          break foundFeature;\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (this.renderedTiles.length === 0) {\n      return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoordString = tileGrid\n        .getTileCoordForCoordAndResolution(coordinate, resolution)\n        .toString();\n      const tile =\n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n          this.renderedTiles\n        ).find(\n          (tile) =>\n            tile.tileCoord.toString() === tileCoordString &&\n            tile.getState() === TileState.LOADED,\n        );\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      if (\n        source.getWrapX() &&\n        projection.canWrapX() &&\n        !containsExtent(\n          projectionExtent,\n          tileGrid.getTileCoordExtent(tile.tileCoord),\n        )\n      ) {\n        wrapX(coordinate, projection);\n      }\n      const layerUid = getUid(layer);\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      const features = tile\n        .getSourceTiles()\n        .reduce(\n          (accumulator, sourceTile) =>\n            accumulator.concat(sourceTile.getFeatures()),\n          /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */ ([]),\n        );\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    /** @type {Array<import('../../Feature.js').FeatureLike>} */\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      this.frameState.viewState.projection,\n    );\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    /** @type {Object<string, true>} */\n    const visitedSourceTiles = {};\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const key = sourceTile.getKey();\n        if (key in visitedSourceTiles) {\n          continue;\n        }\n        visitedSourceTiles[key] = true;\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const scaledCanvasSize = [\n      this.context.canvas.width,\n      this.context.canvas.height,\n    ];\n    const declutter = this.getLayer().getDeclutter();\n    const declutterTree = declutter\n      ? frameState.declutter?.[declutter]\n      : undefined;\n    const layerUid = getUid(this.getLayer());\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[layerUid];\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            scaledCanvasSize,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutterTree,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(this.getLayer());\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[layerUid].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */ ([]));\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    /** @type {Object<number, true>} */\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).map(Number).sort(ascending);\n    zIndexKeys.forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile The tile\n   * @param {import('../../Map.js').FrameState} frameState Current frame state\n   * @return {import('../../transform.js').Transform} Transform to use to render this tile\n   */\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    const layerUid = getUid(layer);\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[layerUid].filter((group) =>\n        group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport {assert} from '../asserts.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport BaseVectorLayer from './BaseVector.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/VectorTile.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views, but get lifted above all polygon and line elements.\n *  `'vector'`: Everything is rendered as vectors and the original render order is maintained. Use\n *    this mode for improved performance and visual epxerience on vector tile layers with not too many\n *    rendered features (e.g. for highlighting a subset of features of another layer with the same\n *    source).\n * @property {VectorTileSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer\n * style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=0] The internal tile cache size.  If too small, this will auto-grow to hold\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/VectorTile.js\").default<FeatureType>} [VectorTileSourceType=import(\"../source/VectorTile.js\").default<*>]\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=ExtractedFeatureType<VectorTileSourceType>]\n * @extends {BaseVectorLayer<FeatureType, VectorTileSourceType, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.preload;\n    const cacheSize = options.cacheSize === undefined ? 0 : options.cacheSize;\n    delete options.cacheSize;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(baseOptions);\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    const renderMode = options.renderMode || 'hybrid';\n    assert(\n      renderMode == 'hybrid' || renderMode == 'vector',\n      \"`renderMode` must be `'hybrid'` or `'vector'`\",\n    );\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this, {\n      cacheSize: this.cacheSize_,\n    });\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    return /** @type {Array<FeatureType>} */ (\n      /** @type {*} */ (this.getRenderer().getFeaturesInExtent(extent))\n    );\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n"],"names":["IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","CanvasTileLayerRenderer","layer","options","createTransform","tile","frameState","x","y","w","h","gutter","transition","z","resolution","viewHints","ViewHint","layerRevision","pixelRatio","projection","revision","renderOrder","builderState","source","declutter","sourceTileGrid","tileExtent","sourceTiles","layerUid","getUid","t","tt","sourceTile","TileState","sourceTileCoord","sourceTileExtent","sharedExtent","getIntersection","builderExtent","buffer","bufferedExtent","equals","builderGroup","CanvasBuilderGroup","squaredTolerance","getSquaredRenderTolerance","render","feature","index","styles","styleFunction","dirty","features","i","ii","intersects","executorGroupInstructions","replayExtent","renderingReplayGroup","CanvasExecutorGroup","coordinate","hitTolerance","callback","matches","rotation","tileGrid","hitExtent","boundingExtent","featureCallback","geometry","distanceSq","key","match","renderedTiles","declutteredFeatures","item","found","foundFeature","executorGroups","pixel","resolve","reject","projectionExtent","applyTransform","tileCoordString","containsExtent","wrapX","extent","corner","getTopLeft","tilePixel","accumulator","hitDetectionImageData","tileSize","toSize","transforms","HIT_DETECT_RESOLUTION","createHitDetectionImageData","hitDetect","tileCache","visitedSourceTiles","tileCoord","tileFeatures","j","jj","candidate","event","layerState","context","alpha","hifi","scaledCanvasSize","declutterTree","tiles","DECLUTTER","acc","executorGroup","executorGroupZIndexContexts","usedZIndices","executorGroupZindexContext","ascending","zIndex","zIndexContexts","zIndexContext","tileClipContext","viewState","center","size","width","height","worldOffset","multiply","scale","renderMode","replayTypes","type","tileSource","clips","clipZs","tileClipContexts","ready","group","transform","currentZ","contextSaved","currentClip","clipContext","ZIndexContext","clip","loading","renderFeature","replayState","tileResolution","renderPixelRatio","renderScale","canvasTransform","resetTransform","scaleTransform","pixelScale","translateTransform","VectorTileLayer","BaseVectorLayer","baseOptions","cacheSize","assert","TileProperty","preload","useInterimTilesOnError"],"mappings":"g4BA8CA,MAAMA,GAAgB,CACpB,MAAS,CAAC,UAAW,SAAU,aAAc,QAAS,MAAM,EAC5D,OAAU,CAAC,UAAW,YAAY,EAClC,OAAU,CAAA,CACZ,EAKMC,EAAiB,CACrB,OAAU,CAAC,QAAS,OAAQ,SAAS,EACrC,OAAU,CAAC,UAAW,SAAU,aAAc,QAAS,OAAQ,SAAS,CAC1E,EAQA,MAAMC,WAAsCC,EAAwB,CAKlE,YAAYC,EAAOC,EAAS,CAC1B,MAAMD,EAAOC,CAAO,EAGpB,KAAK,6BAA+B,KAAK,wBAAwB,KAAK,IAAI,EAM1E,KAAK,uBAML,KAAK,oCAAsC,KAM3C,KAAK,kBAML,KAAK,iBAAmB,EAMxB,KAAK,cAAgBC,EAAe,EAMpC,KAAK,kBAAoB,IAC3B,CAaA,SAASC,EAAMC,EAAYC,EAAGC,EAAGC,EAAGC,EAAGC,EAAQC,EAAY,CACzD,KAAK,qBACHP,EACAC,EAAW,WACXA,EAAW,UAAU,UAC3B,EACQ,KAAK,sBAAsBD,CAAI,GACjC,KAAK,iBAAiBA,EAAMC,CAAU,EAExC,MAAM,SAASD,EAAMC,EAAYC,EAAGC,EAAGC,EAAGC,EAAGC,EAAQC,CAAU,CACjE,CAUA,QAAQC,EAAGN,EAAGC,EAAGF,EAAY,CAC3B,MAAMD,EACJ,KAAK,gBAAgBQ,EAAGN,EAAGC,EAAGF,CAAU,EAE1C,GAAI,CAACD,EACH,OAAO,KAIT,MAAMS,EADYR,EAAW,UACA,WACvBS,EAAYT,EAAW,UAI7B,OAHa,EACXS,EAAUC,EAAS,SAAS,GAAKD,EAAUC,EAAS,WAAW,IAErD,CAACX,EAAK,oBAChBA,EAAK,iBAAmBS,GAEnBT,CACT,CAQA,aAAaC,EAAY,CACvB,MAAMW,EAAgB,KAAK,SAAQ,EAAG,YAAW,EACjD,OAAI,KAAK,yBAA2BA,IAClC,KAAK,uBAAyBA,EAC9B,KAAK,cAAc,OAAS,GAEvB,MAAM,aAAaX,CAAU,CACtC,CAQA,qBAAqBD,EAAMa,EAAYC,EAAY,CACjD,MAAMjB,EACJ,KAAK,SAAQ,EAETkB,EAAWlB,EAAM,YAAW,EAC5BmB,EAAcnB,EAAM,eAAc,GAAM,KAExCY,EAAaT,EAAK,iBAClBiB,EAAejB,EAAK,eAAeH,CAAK,EAC9C,GACE,CAACoB,EAAa,OACdA,EAAa,qBAAuBR,GACpCQ,EAAa,kBAAoBF,GACjCE,EAAa,qBAAuBD,EAEpC,OAGF,MAAME,EAASrB,EAAM,UAAS,EACxBsB,EAAY,CAAC,CAACtB,EAAM,aAAY,EAChCuB,EAAiBF,EAAO,YAAW,EAEnCG,EADWH,EAAO,yBAAyBJ,CAAU,EAC/B,mBAAmBd,EAAK,gBAAgB,EAE9DsB,EAAcJ,EAAO,eAAeL,EAAYC,EAAYd,CAAI,EAChEuB,EAAWC,EAAO3B,CAAK,EAC7B,OAAOG,EAAK,sBAAsBuB,CAAQ,EAC1CvB,EAAK,eAAeuB,CAAQ,EAAI,CAAA,EAChCN,EAAa,MAAQ,GACrB,QAASQ,EAAI,EAAGC,EAAKJ,EAAY,OAAQG,EAAIC,EAAI,EAAED,EAAG,CACpD,MAAME,EAAaL,EAAYG,CAAC,EAChC,GAAIE,EAAW,YAAcC,EAAU,OACrC,SAEF,MAAMC,EAAkBF,EAAW,UAC7BG,EACJV,EAAe,mBAAmBS,CAAe,EAC7CE,EAAeC,EAAgBX,EAAYS,CAAgB,EAC3DG,EAAgBC,EACpBH,EACAlC,EAAM,gBAAe,EAAKY,EAC1B,KAAK,UACb,EACY0B,EAAiBC,EAAON,EAAkBC,CAAY,EACxD,KACAE,EACEI,EAAe,IAAIC,EACvB,EACAP,EACAtB,EACAI,CACR,EACY0B,EAAmBC,GACvB/B,EACAI,CACR,EAOY4B,EAAS,SAAUC,EAASC,EAAO,CACvC,IAAIC,EACJ,MAAMC,EACJH,EAAQ,iBAAgB,GAAM7C,EAAM,iBAAgB,EAItD,GAHIgD,IACFD,EAASC,EAAcH,EAASjC,CAAU,GAExCmC,EAAQ,CACV,MAAME,EAAQ,KAAK,cACjBJ,EACAH,EACAK,EACAP,EACAlB,EACAwB,CACZ,EACU1B,EAAa,MAAQA,EAAa,OAAS6B,CAC7C,CACF,EAEMC,EAAWpB,EAAW,YAAW,EACnCX,GAAeA,IAAgBC,EAAa,qBAC9C8B,EAAS,KAAK/B,CAAW,EAE3B,QAASgC,EAAI,EAAGC,EAAKF,EAAS,OAAQC,EAAIC,EAAI,EAAED,EAAG,CACjD,MAAMN,EAAUK,EAASC,CAAC,GAExB,CAACb,GACDe,EAAWf,EAAgBO,EAAQ,YAAW,EAAG,UAAS,CAAE,IAE5DD,EAAO,KAAK,KAAMC,EAASM,CAAC,CAEhC,CACA,MAAMG,EAA4Bd,EAAa,OAAM,EAE/Ce,EACJvD,EAAM,cAAa,IAAO,UAC1BsB,GACAG,EAAY,SAAW,EACnB,KACAS,EACAsB,EAAuB,IAAIC,EAC/BF,EACA3C,EACAI,EACAK,EAAO,YAAW,EAClBiC,EACAtD,EAAM,gBAAe,EACrB,EACR,EACMG,EAAK,eAAeuB,CAAQ,EAAE,KAAK8B,CAAoB,CACzD,CACApC,EAAa,iBAAmBF,EAChCE,EAAa,oBAAsBD,EACnCC,EAAa,mBAAqBR,CACpC,CAYA,2BACE8C,EACAtD,EACAuD,EACAC,EACAC,EACA,CACA,MAAMjD,EAAaR,EAAW,UAAU,WAClC0D,EAAW1D,EAAW,UAAU,SACtCuD,EAAeA,GAA4B,EAC3C,MAAM3D,EAAQ,KAAK,SAAQ,EAErB+D,EADS/D,EAAM,UAAS,EACN,yBACtBI,EAAW,UAAU,UAC3B,EAEU4D,EAAYC,EAAe,CAACP,CAAU,CAAC,EAC7CrB,EAAO2B,EAAWpD,EAAa+C,EAAcK,CAAS,EAGtD,MAAMd,EAAW,CAAA,EAQXgB,EAAkB,SAAUrB,EAASsB,EAAUC,EAAY,CAC/D,IAAIC,EAAMxB,EAAQ,MAAK,EACnBwB,IAAQ,SACVA,EAAM1C,EAAOkB,CAAO,GAEtB,MAAMyB,EAAQpB,EAASmB,CAAG,EAC1B,GAAKC,GAcE,GAAIA,IAAU,IAAQF,EAAaE,EAAM,WAAY,CAC1D,GAAIF,IAAe,EACjB,OAAAlB,EAASmB,CAAG,EAAI,GAChBR,EAAQ,OAAOA,EAAQ,YAAYS,CAAK,EAAG,CAAC,EACrCV,EAASf,EAAS7C,EAAOmE,CAAQ,EAE1CG,EAAM,SAAWH,EACjBG,EAAM,WAAaF,CACrB,MAtBY,CACV,GAAIA,IAAe,EACjB,OAAAlB,EAASmB,CAAG,EAAI,GACTT,EAASf,EAAS7C,EAAOmE,CAAQ,EAE1CN,EAAQ,KACLX,EAASmB,CAAG,EAAI,CACf,QAASxB,EACT,MAAO7C,EACP,SAAUmE,EACV,WAAYC,EACZ,SAAUR,CACtB,CACA,CACM,CAUF,EAEMW,EAEF,KAAK,cAEH7C,EAAWC,EAAO3B,CAAK,EACvBsB,EAAYtB,EAAM,aAAY,EAC9BwE,EAAsBlD,EACxBlB,EAAW,YAAYkB,CAAS,GAAG,IAAG,EAAG,IAAKmD,GAASA,EAAK,KAAK,EACjE,KACJ,IAAIC,EACJC,EAAc,QAASxB,EAAI,EAAGC,EAAKmB,EAAc,OAAQpB,EAAIC,EAAI,EAAED,EAAG,CACpE,MAAMhD,EAAOoE,EAAcpB,CAAC,EACtB3B,EAAauC,EAAS,mBAAmB5D,EAAK,gBAAgB,EACpE,GAAI,CAACkD,EAAW7B,EAAYwC,CAAS,EACnC,SAGF,MAAMY,EAAiBzE,EAAK,eAAeuB,CAAQ,EACnD,QAASE,EAAI,EAAGC,EAAK+C,EAAe,OAAQhD,EAAIC,EAAI,EAAED,EASpD,GARA8C,EAAQE,EAAehD,CAAC,EAAE,2BACxB8B,EACA9C,EACAkD,EACAH,EACAO,EACAM,CACV,EACYE,EACF,MAAMC,CAGZ,CACA,OAAOD,CACT,CAQA,YAAYG,EAAO,CACjB,OAAI,KAAK,cAAc,SAAW,EACzB,QAAQ,QAAQ,EAAE,EAEpB,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,MAAM/E,EAAQ,KAAK,SAAQ,EACrBqB,EAASrB,EAAM,UAAS,EACxBiB,EAAa,KAAK,mBAClB+D,EAAmB/D,EAAW,UAAS,EACvCL,EAAa,KAAK,mBAClBmD,EAAW1C,EAAO,yBAAyBJ,CAAU,EACrDyC,EAAauB,GACjB,KAAK,oCACLJ,EAAM,MAAK,CACnB,EACYK,EAAkBnB,EACrB,kCAAkCL,EAAY9C,CAAU,EACxD,SAAQ,EACLT,EAEF,KAAK,cACL,KACCA,GACCA,EAAK,UAAU,SAAQ,IAAO+E,GAC9B/E,EAAK,aAAe4B,EAAU,MAC1C,EACM,GAAI,CAAC5B,GAAQA,EAAK,mBAAqB,EAAG,CACxC2E,EAAQ,CAAA,CAAE,EACV,MACF,CAEEzD,EAAO,SAAQ,GACfJ,EAAW,SAAQ,GACnB,CAACkE,GACCH,EACAjB,EAAS,mBAAmB5D,EAAK,SAAS,CACpD,GAEQiF,GAAM1B,EAAYzC,CAAU,EAE9B,MAAMS,EAAWC,EAAO3B,CAAK,EACvBqF,EAAStB,EAAS,mBAAmB5D,EAAK,gBAAgB,EAC1DmF,EAASC,GAAWF,CAAM,EAC1BG,EAAY,EACf9B,EAAW,CAAC,EAAI4B,EAAO,CAAC,GAAK1E,GAC7B0E,EAAO,CAAC,EAAI5B,EAAW,CAAC,GAAK9C,CACtC,EACYsC,EAAW/C,EACd,eAAc,EACd,OACC,CAACsF,EAAa3D,IACZ2D,EAAY,OAAO3D,EAAW,aAAa,EACiB,CAAA,CACxE,EACM,IAAI4D,EAAwBvF,EAAK,sBAAsBuB,CAAQ,EAC/D,GAAI,CAACgE,EAAuB,CAC1B,MAAMC,EAAWC,GACf7B,EAAS,YACPA,EAAS,kBAAkBnD,EAAYS,EAAO,UAAU,CACpE,CACA,EACcyC,EAAW,KAAK,kBAChB+B,EAAa,CACjB,KAAK,mBACH9B,EAAS,mBAAmB5D,EAAK,gBAAgB,EACjDS,EACA,EACAkF,EACAH,EAAS,CAAC,EAAIG,EACdH,EAAS,CAAC,EAAIG,EACd,CACZ,CACA,EACQJ,EAAwBK,GACtBJ,EACAE,EACA3C,EACAlD,EAAM,iBAAgB,EACtB+D,EAAS,mBAAmB5D,EAAK,gBAAgB,EACjDA,EAAK,eAAeH,CAAK,EAAE,mBAC3B8D,CACV,EACQ3D,EAAK,sBAAsBuB,CAAQ,EAAIgE,CACzC,CACAZ,EAAQkB,GAAUR,EAAWtC,EAAUwC,CAAqB,CAAC,CAC/D,CAAC,CACH,CAMA,oBAAoBL,EAAQ,CAE1B,MAAMnC,EAAW,CAAA,EACX+C,EAAY,KAAK,aAAY,EACnC,GAAIA,EAAU,SAAQ,IAAO,EAC3B,OAAO/C,EAGT,MAAMa,EADS,KAAK,SAAQ,EAAG,UAAS,EAChB,yBACtB,KAAK,WAAW,UAAU,UAChC,EACUpD,EAAIoD,EAAS,kBAAkB,KAAK,kBAAkB,EAEtDmC,EAAqB,CAAA,EAC3B,OAAAD,EAAU,QAAS9F,GAAS,CAC1B,GAAIA,EAAK,UAAU,CAAC,IAAMQ,GAAKR,EAAK,SAAQ,IAAO4B,EAAU,OAC3D,OAEF,MAAMN,EAActB,EAAK,eAAc,EACvC,QAASgD,EAAI,EAAGC,EAAK3B,EAAY,OAAQ0B,EAAIC,EAAI,EAAED,EAAG,CACpD,MAAMrB,EAAaL,EAAY0B,CAAC,EAC1BkB,EAAMvC,EAAW,OAAM,EAC7B,GAAIuC,KAAO6B,EACT,SAEFA,EAAmB7B,CAAG,EAAI,GAC1B,MAAM8B,EAAYrE,EAAW,UAC7B,GAAIuB,EAAWgC,EAAQtB,EAAS,mBAAmBoC,CAAS,CAAC,EAAG,CAC9D,MAAMC,EAAetE,EAAW,YAAW,EAC3C,GAAIsE,EACF,QAASC,EAAI,EAAGC,EAAKF,EAAa,OAAQC,EAAIC,EAAI,EAAED,EAAG,CACrD,MAAME,EAAYH,EAAaC,CAAC,EAC1BlC,EAAWoC,EAAU,YAAW,EAClClD,EAAWgC,EAAQlB,EAAS,UAAS,CAAE,GACzCjB,EAAS,KAAKqD,CAAS,CAE3B,CAEJ,CACF,CACF,CAAC,EACMrD,CACT,CAMA,oBAAqB,CACnB,MAAMlD,EAAQ,KAAK,SAAQ,EACvBA,EAAM,WAAU,GAAM,KAAK,yBAA2B,QACxDA,EAAM,QAAO,CAEjB,CAOA,wBAAwBwG,EAAO,CAC7B,KAAK,wBAAuB,CAC9B,CAOA,gBAAgBpG,EAAYqG,EAAY,CACtC,MAAMC,EAAU,KAAK,QACfC,EAAQD,EAAQ,YACtBA,EAAQ,YAAcD,EAAW,QACjC,MAAM5F,EAAYT,EAAW,UACvBwG,EAAO,EACX/F,EAAUC,EAAS,SAAS,GAAKD,EAAUC,EAAS,WAAW,GAE3D+F,EAAmB,CACvB,KAAK,QAAQ,OAAO,MACpB,KAAK,QAAQ,OAAO,MAC1B,EACUvF,EAAY,KAAK,SAAQ,EAAG,aAAY,EACxCwF,EAAgBxF,EAClBlB,EAAW,YAAYkB,CAAS,EAChC,OACEI,EAAWC,EAAO,KAAK,SAAQ,CAAE,EACjCoF,EAEF,KAAK,cAET,QAAS5D,EAAI,EAAGC,EAAK2D,EAAM,OAAQ5D,EAAIC,EAAI,EAAED,EAAG,CAC9C,MAAMhD,EAAO4G,EAAM5D,CAAC,EACdyB,EAAiBzE,EAAK,eAAeuB,CAAQ,EACnD,GAAIkD,EACF,QAASyB,EAAIzB,EAAe,OAAS,EAAGyB,GAAK,EAAG,EAAEA,EAChDzB,EAAeyB,CAAC,EAAE,QAChB,KAAK,QACLQ,EACA,KAAK,uBAAuB1G,EAAMC,CAAU,EAC5CA,EAAW,UAAU,SACrBwG,EACAI,EACAF,CACZ,CAGI,CACAJ,EAAQ,YAAcC,CACxB,CAMA,uBAAuBvG,EAAY,CACjC,MAAM2G,EAEF,KAAK,cAEHrF,EAAWC,EAAO,KAAK,SAAQ,CAAE,EACjCiD,EAAiBmC,EAAM,OAAO,CAACE,EAAK9G,EAAM2C,KAC9C3C,EAAK,eAAeuB,CAAQ,EAAE,QAASwF,GACrCD,EAAI,KAAK,CACP,cAAAC,EACA,MAAApE,CACV,CAAS,CACT,EACamE,GACqE,CAAA,CAAE,EAE1EE,EAA8BvC,EAAe,IAAI,CAAC,CAAC,cAAAsC,CAAa,IACpEA,EAAc,0BAAyB,CAC7C,EAEUE,EAAe,CAAA,EACrB,QAASjE,EAAI,EAAGC,EAAKwB,EAAe,OAAQzB,EAAIC,EAAI,EAAED,EAAG,CACvD,MAAMkE,EACJzC,EAAezB,CAAC,EAAE,cAAc,0BAAyB,EAC3D,UAAWkB,KAAOgD,EAChBD,EAAa/C,CAAG,EAAI,EAExB,CACmB,OAAO,KAAK+C,CAAY,EAAE,IAAI,MAAM,EAAE,KAAKE,EAAS,EAC5D,QAASC,GAAW,CAC7BJ,EAA4B,QAAQ,CAACK,EAAgBrE,IAAM,CACpDqE,EAAeD,CAAM,IAG1BC,EAAeD,CAAM,EAAE,QAASE,GAAkB,CAChD,KAAM,CAAC,cAAAP,EAAe,MAAApE,CAAK,EAAI8B,EAAezB,CAAC,EACzCuD,EAAUQ,EAAc,mBAAkB,EAC1CP,EAAQD,EAAQ,YACtBA,EAAQ,YAAc,KAAK,iBAC3B,MAAMgB,EAAkB,KAAK,kBAAkB5E,CAAK,EAChD4E,GACFA,EAAgB,KAAKhB,CAAO,EAE9Be,EAAc,KAAKf,CAAO,EACtBgB,GACFhB,EAAQ,QAAO,EAEjBA,EAAQ,YAAcC,EACtBc,EAAc,MAAK,CACrB,CAAC,EACDD,EAAeD,CAAM,EAAE,OAAS,EAClC,CAAC,CACH,CAAC,CACH,CAOA,uBAAuBpH,EAAMC,EAAY,CACvC,MAAMY,EAAaZ,EAAW,WACxBuH,EAAYvH,EAAW,UACvBwH,EAASD,EAAU,OACnB/G,EAAa+G,EAAU,WACvB7D,EAAW6D,EAAU,SACrBE,EAAOzH,EAAW,KAClB0H,EAAQ,KAAK,MAAMD,EAAK,CAAC,EAAI7G,CAAU,EACvC+G,EAAS,KAAK,MAAMF,EAAK,CAAC,EAAI7G,CAAU,EAGxC+C,EADS,KAAK,SAAQ,EAAG,UAAS,EAChB,yBACtB3D,EAAW,UAAU,UAC3B,EACU+F,EAAYhG,EAAK,UACjBqB,EAAauC,EAAS,mBAAmB5D,EAAK,gBAAgB,EAC9D6H,EACJjE,EAAS,mBAAmBoC,EAAW,KAAK,UAAU,EAAE,CAAC,EACzD3E,EAAW,CAAC,EAad,OAZkByG,GAChBC,EAAM,KAAK,sBAAsB,MAAK,EAAI,EAAIlH,EAAY,EAAIA,CAAU,EACxE,KAAK,mBACH4G,EACAhH,EACAkD,EACA9C,EACA8G,EACAC,EACAC,CACR,CACA,CAEE,CAQA,WAAWtB,EAAStG,EAAY,CAC9B,MAAMS,EAAYT,EAAW,UACvBwG,EAAO,EACX/F,EAAUC,EAAS,SAAS,GAAKD,EAAUC,EAAS,WAAW,GAGjE,KAAK,oCACHV,EAAW,2BAA2B,MAAK,EAC7C,KAAK,kBAAoBA,EAAW,UAAU,SAC9C,KAAK,iBACHA,EAAW,iBAAiBA,EAAW,UAAU,EAAE,QAErD,MAAMJ,EACJ,KAAK,SAAQ,EAETmI,EAAanI,EAAM,cAAa,EAChC2G,EAAQD,EAAQ,YACtBA,EAAQ,YAAc,KAAK,iBAC3B,MAAMpF,EAAYtB,EAAM,aAAY,EAC9BoI,EAAc9G,EAChBzB,EAAesI,CAAU,EAAE,OAAQE,GAAS,CAACrB,EAAU,SAASqB,CAAI,CAAC,EACrExI,EAAesI,CAAU,EACvBR,EAAYvH,EAAW,UACvB0D,EAAW6D,EAAU,SACrBW,EAAatI,EAAM,UAAS,EAE5BW,EADW2H,EAAW,yBAAyBX,EAAU,UAAU,EACtD,kBACjBA,EAAU,WACVW,EAAW,UACjB,EAEUvB,EAEF,KAAK,cAEHwB,EAAQ,CAAA,EACRC,EAAS,CAAA,EACTC,EAAmB,CAAA,EACnB/G,EAAWC,EAAO3B,CAAK,EAC7B,IAAI0I,EAAQ,GACZ,QAASvF,EAAI4D,EAAM,OAAS,EAAG5D,GAAK,EAAG,EAAEA,EAAG,CAC1C,MAAMhD,EAAO4G,EAAM5D,CAAC,EACpBuF,EAAQA,GAAS,CAACvI,EAAK,eAAeH,CAAK,EAAE,MAC7C,MAAM4E,EAAiBzE,EAAK,eAAeuB,CAAQ,EAAE,OAAQiH,GAC3DA,EAAM,aAAaP,CAAW,CACtC,EACM,GAAIxD,EAAe,SAAW,EAC5B,SAEF,MAAMgE,EAAY,KAAK,uBAAuBzI,EAAMC,CAAU,EACxDyI,EAAW1I,EAAK,UAAU,CAAC,EACjC,IAAI2I,EAAe,GAEnB,MAAMC,EAAcnE,EAAe,CAAC,EAAE,cAAcgE,CAAS,EAC7D,IAAII,EAActC,EACdgB,EACJ,GAAIqB,EAAa,CACfrB,EAAkB,IAAIuB,GACtBD,EAActB,EAAgB,WAAU,EACxC,QAASrB,EAAI,EAAGC,EAAKiC,EAAM,OAAQlC,EAAIC,EAAI,EAAED,EAC3C,GAAI1F,IAAMkI,GAAYA,EAAWL,EAAOnC,CAAC,EAAG,CAC1C,MAAM6C,EAAOX,EAAMlC,CAAC,EAElBhD,EACE,CACE0F,EAAY,CAAC,EACbA,EAAY,CAAC,EACbA,EAAY,CAAC,EACbA,EAAY,CAAC,CAC/B,EACgB,CAACG,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACnD,IAEmBJ,IACHE,EAAY,KAAI,EAChBF,EAAe,IAEjBE,EAAY,UAAS,EAErBA,EAAY,OAAOD,EAAY,CAAC,EAAGA,EAAY,CAAC,CAAC,EACjDC,EAAY,OAAOD,EAAY,CAAC,EAAGA,EAAY,CAAC,CAAC,EACjDC,EAAY,OAAOD,EAAY,CAAC,EAAGA,EAAY,CAAC,CAAC,EACjDC,EAAY,OAAOD,EAAY,CAAC,EAAGA,EAAY,CAAC,CAAC,EAEjDC,EAAY,OAAOE,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EACnCF,EAAY,OAAOE,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EACnCF,EAAY,OAAOE,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EACnCF,EAAY,OAAOE,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EACnCF,EAAY,KAAI,EAEpB,CAEFT,EAAM,KAAKQ,CAAW,EACtBP,EAAO,KAAKK,CAAQ,CACtB,CACA,QAASjH,EAAI,EAAGC,EAAK+C,EAAe,OAAQhD,EAAIC,EAAI,EAAED,EAC9BgD,EAAehD,CAAC,EACxB,QACZ8E,EACA,CAACA,EAAQ,OAAO,MAAOA,EAAQ,OAAO,MAAM,EAC5CkC,EACA9E,EACA8C,EACAwB,EACAhI,EAAW,YAAYkB,CAAS,CAC1C,EAEUwH,IACEE,IAAgBtC,EAClBsC,EAAY,QAAO,EAEnBP,EAAiBtF,CAAC,EAAIuE,EAG5B,CACAhB,EAAQ,YAAcC,EACtB,KAAK,MAAQ+B,EACb,KAAK,kBAAoBD,EACpBrI,EAAW,WACd,KAAK,uBAAuBA,CAAU,EAGxC,MAAM,WAAWsG,EAAStG,CAAU,CACtC,CAWA,cACEyC,EACAH,EACAK,EACAP,EACAlB,EACAwB,EACA,CACA,GAAI,CAACC,EACH,MAAO,GAET,IAAIoG,EAAU,GACd,GAAI,MAAM,QAAQpG,CAAM,EACtB,QAASI,EAAI,EAAGC,EAAKL,EAAO,OAAQI,EAAIC,EAAI,EAAED,EAC5CgG,EACEC,EACE5G,EACAK,EACAE,EAAOI,CAAC,EACRT,EACA,KAAK,6BACL,OACApB,EACAwB,CACZ,GAAeqG,OAGTA,EAAUC,EACR5G,EACAK,EACAE,EACAL,EACA,KAAK,6BACL,OACApB,EACAwB,CACR,EAEI,OAAOqG,CACT,CAOA,sBAAsBhJ,EAAM,CAC1B,MAAMH,EACJ,KAAK,SAAQ,EAEf,GAAIA,EAAM,cAAa,IAAO,SAC5B,MAAO,GAET,MAAMqJ,EAAclJ,EAAK,eAAeH,CAAK,EACvCkB,EAAWlB,EAAM,YAAW,EAC5BY,EAAaT,EAAK,iBACxB,OACEkJ,EAAY,yBAA2BzI,GACvCyI,EAAY,uBAAyBnI,CAEzC,CAOA,iBAAiBf,EAAMC,EAAY,CACjC,MAAMJ,EACJ,KAAK,SAAQ,EAETqJ,EAAclJ,EAAK,eAAeH,CAAK,EACvCkB,EAAWlB,EAAM,YAAW,EAC5B4E,EAAiBzE,EAAK,eAAewB,EAAO3B,CAAK,CAAC,EACxDqJ,EAAY,qBAAuBnI,EAEnC,MAAMiF,EAAYhG,EAAK,iBACjBQ,EAAIwF,EAAU,CAAC,EACf9E,EAASrB,EAAM,UAAS,EAC9B,IAAIgB,EAAaZ,EAAW,WAE5B,MAAMa,EADYb,EAAW,UACA,WACvB2D,EAAW1C,EAAO,yBAAyBJ,CAAU,EACrDqI,EAAiBvF,EAAS,cAAc5D,EAAK,UAAU,CAAC,CAAC,EACzDoJ,EACHnJ,EAAW,WAAaD,EAAK,iBAAoBmJ,EAC9C1I,EAAamD,EAAS,cAAcpD,CAAC,EACrC+F,EAAUvG,EAAK,WAAU,EAG/Ba,EAAa,KAAK,MAChB,KAAK,IAAIA,EAAYuI,EAAmBvI,CAAU,CACxD,EACI,MAAM6G,EAAOxG,EAAO,iBAAiBV,EAAGK,EAAYC,CAAU,EAC9DyF,EAAQ,OAAO,MAAQmB,EAAK,CAAC,EAC7BnB,EAAQ,OAAO,OAASmB,EAAK,CAAC,EAC9B,MAAM2B,EAAcxI,EAAauI,EACjC,GAAIC,IAAgB,EAAG,CACrB,MAAMC,EAAkBC,EAAe,KAAK,aAAa,EACzDC,EAAeF,EAAiBD,EAAaA,CAAW,EACxD9C,EAAQ,aAAa,MAAMA,EAAS+C,CAAe,CACrD,CACA,MAAMjI,EAAauC,EAAS,mBAAmBoC,EAAW,KAAK,UAAU,EACnEyD,EAAaL,EAAmB3I,EAChCgI,EAAYc,EAAe,KAAK,aAAa,EACnDC,EAAef,EAAWgB,EAAY,CAACA,CAAU,EACjDC,GAAmBjB,EAAW,CAACpH,EAAW,CAAC,EAAG,CAACA,EAAW,CAAC,CAAC,EAC5D,QAAS2B,EAAI,EAAGC,EAAKwB,EAAe,OAAQzB,EAAIC,EAAI,EAAED,EAC9ByB,EAAezB,CAAC,EACxB,QACZuD,EACA,CACEA,EAAQ,OAAO,MAAQ8C,EACvB9C,EAAQ,OAAO,OAAS8C,CAClC,EACQZ,EACA,EACA,GACAhJ,GAAcI,EAAM,eAAe,EACnC,IACR,EAEIqJ,EAAY,uBAAyBlJ,EAAK,gBAC5C,CACF,CC12BA,MAAM2J,WAAwBC,EAAgB,CAI5C,YAAY9J,EAAS,CACnBA,EAAUA,GAAoB,CAAA,EAE9B,MAAM+J,EAAc,OAAO,OAAO,CAAA,EAAI/J,CAAO,EAC7C,OAAO+J,EAAY,QACnB,MAAMC,EAAYhK,EAAQ,YAAc,OAAY,EAAIA,EAAQ,UAChE,OAAOA,EAAQ,UACf,OAAO+J,EAAY,uBAEnB,MAAMA,CAAW,EAKjB,KAAK,GAKL,KAAK,KAKL,KAAK,GAML,KAAK,WAAaC,EAElB,MAAM9B,EAAalI,EAAQ,YAAc,SACzCiK,GACE/B,GAAc,UAAYA,GAAc,SACxC,+CACN,EAMI,KAAK,YAAcA,EAEnB,KAAK,WAAWlI,EAAQ,QAAUA,EAAQ,QAAU,CAAC,EACrD,KAAK,0BACHA,EAAQ,yBAA2B,OAC/BA,EAAQ,uBACR,EACV,EAOI,KAAK,cAOL,KAAK,aACP,CAKA,gBAAiB,CACf,OAAO,IAAIH,GAA8B,KAAM,CAC7C,UAAW,KAAK,UACtB,CAAK,CACH,CAiBA,YAAY+E,EAAO,CACjB,OAAO,MAAM,YAAYA,CAAK,CAChC,CAcA,oBAAoBQ,EAAQ,CAC1B,OACoB,KAAK,YAAW,EAAG,oBAAoBA,CAAM,CAEnE,CAKA,eAAgB,CACd,OAAO,KAAK,WACd,CAQA,YAAa,CACX,OAA8B,KAAK,IAAI8E,EAAa,OAAO,CAC7D,CAQA,2BAA4B,CAC1B,OACE,KAAK,IAAIA,EAAa,0BAA0B,CAEpD,CAQA,WAAWC,EAAS,CAClB,KAAK,IAAID,EAAa,QAASC,CAAO,CACxC,CAQA,0BAA0BC,EAAwB,CAChD,KAAK,IAAIF,EAAa,2BAA4BE,CAAsB,CAC1E,CACF","x_google_ignoreList":[0,1]}